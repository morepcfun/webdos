<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebDOS</title>
  <style>
    :root {
      --black: #000000;
      --green: var(--green-7);
      --green-0: #051a00;
      --green-1: #133b03;
      --green-2: #215b06;
      --green-3: #2e7c09;
      --green-4: #3c9d0b;
      --green-5: #4ab50e;
      --green-6: #58de11;
      --green-7: #65ff14;
    }
    html,
    body {
      margin: 0;
      padding: 0;
      background-color: var(--black);
      color: var(--green);
      font-family: 'Courier New', Courier, monospace;
      font-size: 20px;
    }
    #terminal {
      padding: 10px;
    }
    .output-line {
      white-space: pre-wrap;
    }
    .input-line {
      display: flex;
      align-items: center;
      height: 1.2em;
    }
    .prompt {
      flex-shrink: 0;
    }
    .input-text {
      padding-right: 1ch;
      white-space: pre;
    }
    #cursor {
      display: inline-block;
      background-color: var(--green);
      width: 1ch;
      height: 0.9em;
      animation: blink 1s step-end infinite;
      margin-left: -1ch;
      margin-bottom: 0.2ch;
    }
    @keyframes blink {
      from,
      to {
        background-color: transparent;
      }
      50% {
        background-color: var(--green);
      }
    }
  </style>
</head>
<body>
  <div id="terminal">
    <div class="input-line">
      <span class="prompt">C:\&gt;</span>
      <span id="input-buffer" class="input-text"></span>
      <span id="cursor"></span>
    </div>
  </div>
<script>
  const SystemPrograms = [];

  // -------- START PROGRAM: ABOUT --------
  const aboutProgram = {
    name: 'about',
    program: {
      description: 'Prints information about this system.',
      execute: async (term) => {
        term.print("WebDOS [Version 1.0]");
        term.print("(c) 2025. A self-contained terminal environment.");
      }
    }
  };
  SystemPrograms.push(aboutProgram);
  // -------- END PROGRAM: ABOUT --------

  // -------- START PROGRAM: COLORS --------
  const colorsProgram = {
    name: 'colors',
    program: {
      description: 'Displays all 8 colors in the system palette.',
      execute: async (term) => {
        term.print('--- Testing the system 8-color palette ---');
        for (let i = 0; i <= 7; i++) {
          const colorVar = `var(--green-${i})`;
          term.print(`Sample text in --green-${i}`, { color: colorVar });
        }
        term.print('--- End of palette ---', {
          color: 'var(--black)',
          backgroundColor: 'var(--green-7)'
        });
      }
    }
  };
  SystemPrograms.push(colorsProgram);
  // -------- END PROGRAM: COLORS --------

  // -------- START PROGRAM: TETRIS --------
  const tetrisProgram = {
    name: 'tetris',
    program: {
      description: 'A classic block-stacking game.',
      execute: async (term) => {
        return new Promise(resolve => {
          const BOARD_WIDTH = 10, BOARD_HEIGHT = 20, SCORES_KEY = 'webdos_tetris_highscores';
          const COLORS = { BORDER: 'var(--green-4)', SCORE_TEXT: 'var(--green-6)', LOCKED_PIECE: 'var(--green-5)', GHOST_PIECE: 'var(--green-3)', ACTIVE_PIECE: 'var(--green-7)', GAME_OVER: 'var(--green-7)' };
          const PIECES = { 'I': [[1, 1, 1, 1]], 'O': [[1, 1], [1, 1]], 'T': [[0, 1, 0], [1, 1, 1]], 'L': [[0, 0, 1], [1, 1, 1]], 'J': [[1, 0, 0], [1, 1, 1]], 'S': [[0, 1, 1], [1, 1, 0]], 'Z': [[1, 1, 0], [0, 1, 1]] };
          const PIECE_TYPES = 'IOTLJSZ';

          let board, score, lines, gameOver, currentPiece, nextPiece, gameLoopId, gameState = 'start';
          const inputLine = document.querySelector('.input-line');

          const getHighScores = () => { try { const scores = localStorage.getItem(SCORES_KEY); return scores ? JSON.parse(scores) : []; } catch (e) { return []; } };
          const saveHighScore = (newScore) => { if (newScore === 0) return; const scores = getHighScores(); scores.push({ score: newScore, date: new Date().toLocaleDateString() }); scores.sort((a, b) => b.score - a.score); localStorage.setItem(SCORES_KEY, JSON.stringify(scores.slice(0, 10))); };

          const exitGame = (message) => {
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            document.removeEventListener('keydown', masterInputHandler, { capture: true });
            term.clear();
            if (message) term.print(message);
            inputLine.style.display = 'flex';
            resolve();
          };

          const createEmptyBoard = () => Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0));
          const spawnPiece = () => { currentPiece = nextPiece; const type = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)]; nextPiece = { shape: PIECES[type], x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 }; if (checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y)) { gameOver = true; } };
          const checkCollision = (shape, x, y) => { for (let row = 0; row < shape.length; row++) { for (let col = 0; col < shape[row].length; col++) { if (shape[row][col]) { let boardX = x + col; let boardY = y + row; if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT || (boardY >= 0 && board[boardY][boardX])) { return true; } } } } return false; };
          const rotatePiece = () => { const shape = currentPiece.shape; const newShape = shape[0].map((_, colIndex) => shape.map(row => row[colIndex]).reverse()); if (!checkCollision(newShape, currentPiece.x, currentPiece.y)) { currentPiece.shape = newShape; } };
          const lockPiece = () => { currentPiece.shape.forEach((row, y) => { row.forEach((value, x) => { if (value && (currentPiece.y + y) >= 0) { board[currentPiece.y + y][currentPiece.x + x] = 1; } }); }); };

          const clearLines = () => {
            let linesCleared = 0;
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
              if (board[y].every(cell => cell !== 0)) {
                linesCleared++;
                board.splice(y, 1);
                board.unshift(Array(BOARD_WIDTH).fill(0));
                y++;
              }
            }
            if (linesCleared > 0) {
              lines += linesCleared;
              score += (linesCleared * 100) * linesCleared;
            }
          };

          const getGhostPosition = () => { let ghostY = currentPiece.y; while (!checkCollision(currentPiece.shape, currentPiece.x, ghostY + 1)) { ghostY++; } return ghostY; };

          const draw = () => {
            term.clear();
            const ghostY = getGhostPosition();
            const outputBuffer = [];
            outputBuffer.push(`<span style="color:${COLORS.BORDER}">‚ïî${'‚ïê‚ïê'.repeat(BOARD_WIDTH)}‚ïó</span>`);
            for (let y = 0; y < BOARD_HEIGHT; y++) {
              let line = `<span style="color:${COLORS.BORDER}">‚ïë</span>`;
              for (let x = 0; x < BOARD_WIDTH; x++) {
                const pieceX = x - currentPiece.x, pieceY = y - currentPiece.y, ghostPieceY = y - ghostY;
                const isPiece = pieceY >= 0 && pieceY < currentPiece.shape.length && pieceX >= 0 && pieceX < currentPiece.shape[pieceY].length && currentPiece.shape[pieceY][pieceX];
                const isGhost = ghostPieceY >= 0 && ghostPieceY < currentPiece.shape.length && pieceX >= 0 && pieceX < currentPiece.shape[ghostPieceY].length && currentPiece.shape[ghostPieceY][pieceX];
                if (isPiece) { line += `<span style="color:${COLORS.ACTIVE_PIECE}">‚ñà‚ñà</span>`; }
                else if (isGhost) { line += `<span style="color:${COLORS.GHOST_PIECE}">‚ñë‚ñë</span>`; }
                else if (board[y][x]) { line += `<span style="color:${COLORS.LOCKED_PIECE}">‚ñì‚ñì</span>`; }
                else { line += '  '; }
              }
              line += `<span style="color:${COLORS.BORDER}">‚ïë</span>`;
              outputBuffer.push(line);
            }
            outputBuffer.push(`<span style="color:${COLORS.BORDER}">‚ïö${'‚ïê‚ïê'.repeat(BOARD_WIDTH)}‚ïù</span>`);
            outputBuffer.push(`<span style="color:${COLORS.SCORE_TEXT}">  Score: ${score}   Lines: ${lines}</span>`);
            outputBuffer.push(`<span style="color:${COLORS.SCORE_TEXT}">  Next:</span>`);
            if (nextPiece && nextPiece.shape) {
              nextPiece.shape.forEach(row => {
                const nextPieceLine = '  ' + row.map(cell => cell ? '‚ñà‚ñà' : '  ').join('');
                outputBuffer.push(`<span style="color:${COLORS.ACTIVE_PIECE}">${nextPieceLine}</span>`);
              });
            }
            term.print(outputBuffer.join('\n'));
          };

          const masterInputHandler = (e) => {
            if (e.altKey && e.key.toLowerCase() === 'q') { e.preventDefault(); e.stopImmediatePropagation(); exitGame("Tetris exited by user."); return; }
            e.stopImmediatePropagation();
            switch (gameState) {
              case 'start': e.preventDefault(); gameState = 'playing'; runGame(); break;
              case 'playing':
                if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', ' '].includes(e.key)) e.preventDefault();
                if (e.key === 'ArrowLeft') { if (!checkCollision(currentPiece.shape, currentPiece.x - 1, currentPiece.y)) currentPiece.x--; }
                else if (e.key === 'ArrowRight') { if (!checkCollision(currentPiece.shape, currentPiece.x + 1, currentPiece.y)) currentPiece.x++; }
                else if (e.key === 'ArrowDown') { if (!checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) { currentPiece.y++; score += 1; } else { lockPiece(); clearLines(); spawnPiece(); } }
                else if (e.key === 'ArrowUp') { rotatePiece(); }
                else if (e.key === ' ') { const ghostY = getGhostPosition(); score += (ghostY - currentPiece.y) * 2; currentPiece.y = ghostY; lockPiece(); clearLines(); spawnPiece(); }
                draw();
                break;
            }
          };

          const showStartScreen = () => {
            term.clear();
            term.print("=== TETRIS ===", { color: COLORS.SCORE_TEXT });
            term.print("Controls:\n  Left/Right: Move\n  Up: Rotate\n  Down: Soft drop\n  Spacebar: Hard drop\n  Alt+Q: Force quit\n");
            term.print("Top 10 High Scores:");
            const highScores = getHighScores();
            if (highScores.length === 0) { term.print("  No high scores yet. Be the first!"); }
            else { highScores.forEach((s, i) => term.print(`${(i + 1).toString().padStart(2)}. ${s.score.toString().padStart(6, ' ')} (${s.date})`)); }
            term.print("\nPress any key to start...");
          };

          const runGame = () => {
            board = createEmptyBoard(); score = 0; lines = 0; gameOver = false;
            const firstType = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
            nextPiece = { shape: PIECES[firstType], x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 };
            spawnPiece();
            let lastTime = 0; let dropCounter = 0;
            const gameLoop = (time = 0) => {
              if (gameOver) {
                saveHighScore(score);
                term.print(`\n<span style='color: ${COLORS.GAME_OVER};'>Game Over!</span>`);
                term.print("To play again, type 'tetris' and press Enter.");
                cancelAnimationFrame(gameLoopId);
                document.removeEventListener('keydown', masterInputHandler, { capture: true });
                inputLine.style.display = 'flex';
                resolve(); return;
              }
              const deltaTime = time - lastTime; lastTime = time; dropCounter += deltaTime;
              if (dropCounter > 1000) { if (checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) { lockPiece(); clearLines(); spawnPiece(); } else { currentPiece.y++; } dropCounter = 0; }
              draw();
              gameLoopId = requestAnimationFrame(gameLoop);
            };
            gameLoop();
          };

          inputLine.style.display = 'none';
          document.addEventListener('keydown', masterInputHandler, { capture: true });
          showStartScreen();
        });
      }
    }
  };
  SystemPrograms.push(tetrisProgram);
  // -------- END PROGRAM: TETRIS --------

  // -------- START PROGRAM: SNAKE --------
  const snakeProgram = {
    name: 'snake',
    program: {
      description: 'A classic snake game. The speed increases!',
      execute: async (term) => {
        return new Promise(resolve => {
          const BOARD_WIDTH = 25, BOARD_HEIGHT = 18, SCORES_KEY = 'webdos_snake_highscores';
          const COLORS = { BORDER: 'var(--green-4)', SCORE_TEXT: 'var(--green-6)', SNAKE_HEAD: 'var(--green-7)', SNAKE_BODY: 'var(--green-5)', FOOD: 'var(--green-6)', GAME_OVER: 'var(--green-7)' };
          const CHARS = { SNAKE_HEAD: '‚ñà‚ñà', SNAKE_BODY: '‚ñì‚ñì', FOOD: '‚ñà‚ñà' };
          let snake, food, score, gameOver, direction, gameLoopId, gameState = 'start', gameSpeed;
          const inputLine = document.querySelector('.input-line');
          const getHighScores = () => { try { const scores = localStorage.getItem(SCORES_KEY); return scores ? JSON.parse(scores) : []; } catch (e) { return []; } };
          const saveHighScore = (newScore) => { if (newScore === 0) return; const scores = getHighScores(); scores.push({ score: newScore, date: new Date().toLocaleDateString() }); scores.sort((a, b) => b.score - a.score); localStorage.setItem(SCORES_KEY, JSON.stringify(scores.slice(0, 10))); };

          const exitGame = (message) => {
            if (gameLoopId) clearTimeout(gameLoopId);
            document.removeEventListener('keydown', masterInputHandler, { capture: true });
            term.clear();
            if (message) term.print(message);
            inputLine.style.display = 'flex';
            resolve();
          };

          const placeFood = () => {
            while (true) {
              food = { x: Math.floor(Math.random() * BOARD_WIDTH), y: Math.floor(Math.random() * BOARD_HEIGHT) };
              if (!snake.some(segment => segment.x === food.x && segment.y === food.y)) break;
            }
          };

          const initGame = () => {
            snake = [{ x: Math.floor(BOARD_WIDTH / 2), y: Math.floor(BOARD_HEIGHT / 2) }];
            direction = { x: 0, y: 0 };
            score = 0; gameOver = false; gameSpeed = 300; // Slower start speed
            gameState = 'playing';
            placeFood();
            gameLoop();
          };

          const draw = () => {
            term.clear();
            const outputBuffer = [];
            outputBuffer.push(`<span style="color:${COLORS.BORDER}">‚ïî${'‚ïê‚ïê'.repeat(BOARD_WIDTH)}‚ïó</span>`);
            for (let y = 0; y < BOARD_HEIGHT; y++) {
              let line = `<span style="color:${COLORS.BORDER}">‚ïë</span>`;
              for (let x = 0; x < BOARD_WIDTH; x++) {
                const isHead = snake[0].x === x && snake[0].y === y;
                const isBody = snake.slice(1).some(seg => seg.x === x && seg.y === y);
                const isFood = food.x === x && food.y === y;
                if (isHead) line += `<span style="color:${COLORS.SNAKE_HEAD}">${CHARS.SNAKE_HEAD}</span>`;
                else if (isBody) line += `<span style="color:${COLORS.SNAKE_BODY}">${CHARS.SNAKE_BODY}</span>`;
                else if (isFood) line += `<span style="color:${COLORS.FOOD}">${CHARS.FOOD}</span>`;
                else line += '  ';
              }
              line += `<span style="color:${COLORS.BORDER}">‚ïë</span>`;
              outputBuffer.push(line);
            }
            outputBuffer.push(`<span style="color:${COLORS.BORDER}">‚ïö${'‚ïê‚ïê'.repeat(BOARD_WIDTH)}‚ïù</span>`);
            outputBuffer.push(`<span style="color:${COLORS.SCORE_TEXT}">  Score: ${score} | Speed: ${((150 / gameSpeed - 0.5) * 2 * 100).toFixed(0)}%</span>`);
            term.print(outputBuffer.join('\n'));
          };

          const masterInputHandler = (e) => {
            if (e.altKey && e.key.toLowerCase() === 'q') { e.preventDefault(); e.stopImmediatePropagation(); exitGame("Snake exited by user."); return; }
            e.stopImmediatePropagation(); e.preventDefault();
            if (gameState === 'start') { initGame(); return; }
            if (gameState === 'playing') {
              switch (e.key) {
                case 'ArrowUp': if (direction.y === 0) direction = { x: 0, y: -1 }; break;
                case 'ArrowDown': if (direction.y === 0) direction = { x: 0, y: 1 }; break;
                case 'ArrowLeft': if (direction.x === 0) direction = { x: -1, y: 0 }; break;
                case 'ArrowRight': if (direction.x === 0) direction = { x: 1, y: 0 }; break;
              }
            }
          };

          const showStartScreen = () => {
            term.clear();
            term.print("=== SNAKE ===", { color: COLORS.SCORE_TEXT });
            term.print("Controls:\n  Arrow keys: Steer the snake\n  Alt+Q: Force quit\n");
            term.print("Top 10 High Scores:");
            const highScores = getHighScores();
            if (highScores.length === 0) { term.print("  No high scores yet. Be the first!"); }
            else { highScores.forEach((s, i) => term.print(`${(i + 1).toString().padStart(2)}. ${s.score.toString().padStart(6, ' ')} (${s.date})`)); }
            term.print("\nPress any key to start...");
          };

          const gameLoop = () => {
            if (gameOver) {
              saveHighScore(score);
              term.print(`\n<span style='color: ${COLORS.GAME_OVER};'>Game Over!</span>`);
              term.print("To play again, type 'snake' and press Enter.");
              document.removeEventListener('keydown', masterInputHandler, { capture: true });
              inputLine.style.display = 'flex';
              resolve(); return;
            }
            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
            if (head.x < 0 || head.x >= BOARD_WIDTH || head.y < 0 || head.y >= BOARD_HEIGHT) gameOver = true;
            if (snake.slice(1).some(seg => seg.x === head.x && seg.y === head.y)) gameOver = true;
            if (direction.x !== 0 || direction.y !== 0) {
              snake.unshift(head);
              if (head.x === food.x && head.y === food.y) {
                score += 10;
                gameSpeed = Math.max(40, gameSpeed * 0.97); // Increase speed!
                placeFood();
              } else {
                snake.pop();
              }
            }
            draw();
            gameLoopId = setTimeout(gameLoop, gameSpeed);
          };

          inputLine.style.display = 'none';
          document.addEventListener('keydown', masterInputHandler, { capture: true });
          showStartScreen();
        });
      }
    }
  };
  SystemPrograms.push(snakeProgram);
  // -------- END PROGRAM: SNAKE --------

  // -------- START PROGRAM: SHITHEAD --------
  const shitheadProgram = {
    name: 'shithead',
    program: {
      description: 'The classic card game. Get rid of your cards!',
      execute: async (term) => {
        return new Promise(resolve => {
          const PLAYER_NAME = "You", AI_NAME = "The Machine", CARD_RANKS = { '3': 1, '4': 2, '5': 3, '6': 4, '7': 5, '8': 6, '9': 7, 'J': 8, 'Q': 9, 'K': 10, 'A': 11, '2': 12, '10': 13 };
          let gameState = {};
          const inputLine = document.querySelector('.input-line');
          const getCardValue = (card) => (card ? card.slice(0, -1) : ''), getCardRank = (card) => card ? CARD_RANKS[getCardValue(card)] || 0 : 0, sortCards = (cards) => cards.sort((a, b) => getCardRank(a) - getCardRank(b));

          const createNewGame = () => {
            const suits = ['H', 'D', 'C', 'S'], values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            let deck = [];
            for (const suit of suits) { for (const value of values) { deck.push(value + suit); } }
            for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[deck[i], deck[j]] = [deck[j], deck[i]]; }
            gameState = {
              players: {
                [PLAYER_NAME]: { name: PLAYER_NAME, hand: sortCards(deck.splice(0, 3)), faceUp: sortCards(deck.splice(0, 3)), faceDown: deck.splice(0, 3) },
                [AI_NAME]: { name: AI_NAME, hand: sortCards(deck.splice(0, 3)), faceUp: sortCards(deck.splice(0, 3)), faceDown: deck.splice(0, 3) },
              },
              deck: deck, discardPile: [], turn: PLAYER_NAME, winner: null, gameInProgress: true, statusMessage: `The game has started. It's your turn!`
            };
          };

          const switchTurn = () => {
            if (gameState.winner) return;
            gameState.turn = gameState.turn === PLAYER_NAME ? AI_NAME : PLAYER_NAME;
            gameState.statusMessage = `It's ${gameState.players[gameState.turn].name}'s turn.`;
            draw();
            if (gameState.turn === AI_NAME) setTimeout(aiTurn, 1200);
          };

          const drawCards = (player) => { const p = gameState.players[player]; while (p.hand.length < 3 && gameState.deck.length > 0) p.hand.push(gameState.deck.pop()); sortCards(p.hand); };
          const checkWinCondition = (player) => { const p = gameState.players[player]; if (p.hand.length === 0 && p.faceUp.length === 0 && p.faceDown.length === 0) { gameState.winner = player; gameState.gameInProgress = false; return true; } return false; };
          const checkFourOfAKind = () => { if (gameState.discardPile.length < 4) return false; const topFour = gameState.discardPile.slice(-4); return topFour.every(c => getCardValue(c) === getCardValue(topFour[0])); };

          const burnPile = (player) => {
            gameState.statusMessage = `${gameState.players[player].name} burned the pile! New turn.`;
            draw();
            setTimeout(() => { gameState.discardPile = []; drawCards(player); if (checkWinCondition(player)) { endGame(); return; } draw(); if (player === AI_NAME) setTimeout(aiTurn, 1000); }, 800);
          };

          const processMove = (player, card, sourcePile) => {
            const source = gameState.players[player][sourcePile];
            const index = source.indexOf(card); if (index > -1) source.splice(index, 1);
            gameState.discardPile.push(card);
            gameState.statusMessage = `${gameState.players[player].name} played ${formatCard(card)}.`;
            if (checkWinCondition(player)) { endGame(); return; }
            if (checkFourOfAKind()) { burnPile(player); return; }
            const cardValue = getCardValue(card);
            if (cardValue === '10') { burnPile(player); return; }
            if (cardValue === '2') { gameState.statusMessage = `The pile was reset. New turn for ${gameState.players[player].name}.`; }
            drawCards(player);
            if (checkWinCondition(player)) { endGame(); return; }
            if (cardValue === '2') { draw(); if (player === AI_NAME) setTimeout(aiTurn, 1000); }
            else { switchTurn(); }
          };

          const getEffectiveTopCard = () => { for (let i = gameState.discardPile.length - 1; i >= 0; i--) { if (getCardValue(gameState.discardPile[i]) !== '2') return gameState.discardPile[i]; } return null; };
          const checkMoveLegality = (cardToPlay) => { const cardValue = getCardValue(cardToPlay); if (cardValue === '2' || cardValue === '10' || gameState.discardPile.length === 0) return true; const effectiveTopCard = getEffectiveTopCard(); if (!effectiveTopCard) return true; return getCardRank(cardToPlay) >= getCardRank(effectiveTopCard); };
          const playerPicksUpPile = (player) => { if (gameState.discardPile.length === 0) { switchTurn(); return; } const p = gameState.players[player]; p.hand.push(...gameState.discardPile); sortCards(p.hand); gameState.discardPile = []; gameState.statusMessage = `${p.name} picked up the pile.`; switchTurn(); };

          const handlePlayerMove = (card, sourcePile) => {
            if (sourcePile !== 'faceDown' && !checkMoveLegality(card)) { gameState.statusMessage = "Invalid move! Play a higher card or take the pile."; draw(); return; }
            if (sourcePile === 'faceDown') {
              if (checkMoveLegality(card)) { gameState.statusMessage = `You played ${formatCard(card)} blind... It was legal!`; processMove(PLAYER_NAME, card, 'faceDown'); }
              else { gameState.statusMessage = `You played ${formatCard(card)} blind... Unlucky!`; const source = gameState.players[PLAYER_NAME].faceDown; const index = source.indexOf(card); if (index > -1) source.splice(index, 1); gameState.discardPile.push(card); draw(); setTimeout(() => playerPicksUpPile(PLAYER_NAME), 800); }
            } else { processMove(PLAYER_NAME, card, sourcePile); }
          };

          const aiTurn = () => {
            if (gameState.turn !== AI_NAME || !gameState.gameInProgress) return;
            const ai = gameState.players[AI_NAME];
            const playableFrom = ai.hand.length > 0 ? 'hand' : ai.faceUp.length > 0 ? 'faceUp' : 'faceDown';
            const cardOptions = ai[playableFrom];
            if (playableFrom === 'faceDown') {
              const cardToPlay = cardOptions[0];
              gameState.statusMessage = `${AI_NAME} is playing blind...`; draw();
              setTimeout(() => { if (checkMoveLegality(cardToPlay)) { processMove(AI_NAME, cardToPlay, 'faceDown'); } else { const source = gameState.players[AI_NAME].faceDown; const index = source.indexOf(cardToPlay); if (index > -1) source.splice(index, 1); gameState.discardPile.push(cardToPlay); playerPicksUpPile(AI_NAME); } }, 500); return;
            }
            const legalMoves = cardOptions.filter(checkMoveLegality);
            if (legalMoves.length === 0) { playerPicksUpPile(AI_NAME); return; }
            const tens = legalMoves.filter(c => getCardValue(c) === '10'); if (tens.length > 0 && gameState.discardPile.length >= 5) { processMove(AI_NAME, tens[0], playableFrom); return; }
            let normalMoves = legalMoves.filter(c => !['2', '10'].includes(getCardValue(c))); if (normalMoves.length > 0) { processMove(AI_NAME, normalMoves[0], playableFrom); return; }
            processMove(AI_NAME, legalMoves[0], playableFrom);
          };

          const formatCard = (cardStr) => { if (!cardStr) return '[   ]'; const suitSymbols = { H: '‚ô•', D: '‚ô¶', C: '‚ô£', S: '‚ô†' }; const value = getCardValue(cardStr).padEnd(2); const suit = suitSymbols[cardStr.slice(-1)]; return `[${value}${suit}]`; };
          const draw = () => {
              term.clear();
              const p = gameState.players[PLAYER_NAME], ai = gameState.players[AI_NAME];
              const topCard = gameState.discardPile.length > 0 ? formatCard(gameState.discardPile[gameState.discardPile.length - 1]) : '[   ]';
              const deckStr = `Deck: ${gameState.deck.length > 0 ? '[??]' : '[  ]'} (${gameState.deck.length})`;
              const pileStr = `Pile: ${topCard} (${gameState.discardPile.length})`;
              const centeredInfo = `${deckStr.padEnd(20)}${pileStr.padStart(20)}`;
              const activePile = p.hand.length > 0 ? p.hand : p.faceUp.length > 0 ? p.faceUp : p.faceDown;
              let handStr, handDisplay;
              if (p.hand.length > 0) { handStr = `Your Hand:`; handDisplay = p.hand.map((c, i) => `${i + 1}:${formatCard(c)}`).join('  '); }
              else if (p.faceUp.length > 0) { handStr = `Your Face-Up:`; handDisplay = p.faceUp.map((c, i) => `${i + 1}:${formatCard(c)}`).join('  '); }
              else { handStr = `Your Face-Down:`; handDisplay = p.faceDown.map((c, i) => `${i + 1}:[??]`).join('  '); }

              let out = [];
              out.push(`+-- ${AI_NAME.padEnd(46, '-')} --+`);
              out.push(`| Hand: ${ai.hand.length} | Face-Up: ${ai.faceUp.map(formatCard).join(' ')}`.padEnd(52) + `|`);
              out.push(`|       | Face-Down: ${ai.faceDown.map(() => '[??]').join(' ')}`.padEnd(52) + `|`);
              out.push(`+${'‚îÄ'.repeat(54)}+`);
              out.push(`| ${centeredInfo.padStart(46).padEnd(52)} |`);
              out.push(`+${'‚îÄ'.repeat(54)}+`);
              out.push(`+-- ${`${PLAYER_NAME}${gameState.turn === PLAYER_NAME ? ' (Your Turn!)' : ''}`.padEnd(46, '-')} --+`);
              out.push(`| Hand: ${p.hand.length} | Face-Up: ${p.faceUp.map(formatCard).join(' ')}`.padEnd(52) + `|`);
              out.push(`|       | Face-Down: ${p.faceDown.map(() => '[??]').join(' ')}`.padEnd(52) + `|`);
              out.push(`+${'‚îÄ'.repeat(54)}+`);
              out.push(`${handStr.padEnd(14)} ${handDisplay}`);
              out.push('\n');
              out.push(`Status: ${gameState.statusMessage}`);
              let controls = `Controls: Select card (1-${activePile.length})`;
              if (!activePile.some(checkMoveLegality) && gameState.discardPile.length > 0) { controls += ", (T)ake pile"; }
              controls += ', (Alt+Q) Quit';
              out.push(controls);
              term.print(out.join('\n'));
          };

          const endGame = () => { gameState.statusMessage = gameState.winner === PLAYER_NAME ? `üéâ YOU WON! ${AI_NAME} is the Shithead!` : `üò≠ YOU LOST! You are the Shithead!`; draw(); setTimeout(() => { term.print("\nType 'shithead' to play again."); exitGame(); }, 2000); };
          const exitGame = () => { document.removeEventListener('keydown', masterInputHandler, { capture: true }); inputLine.style.display = 'flex'; resolve(); };

          const masterInputHandler = (e) => {
            if (!gameState.gameInProgress || (gameState.turn !== PLAYER_NAME)) return;
            if (e.altKey && e.key.toLowerCase() === 'q') { e.preventDefault(); e.stopImmediatePropagation(); exitGame("Shithead exited by user."); return; }
            e.preventDefault(); e.stopImmediatePropagation();
            const p = gameState.players[PLAYER_NAME];
            const activePile = p.hand.length > 0 ? p.hand : p.faceUp.length > 0 ? p.faceUp : p.faceDown;
            const activePileName = p.hand.length > 0 ? 'hand' : p.faceUp.length > 0 ? 'faceUp' : 'faceDown';
            if (!isNaN(e.key) && e.key > 0 && e.key <= activePile.length) { handlePlayerMove(activePile[parseInt(e.key) - 1], activePileName); }
            else if (e.key.toLowerCase() === 't') { if (!activePile.some(checkMoveLegality) && gameState.discardPile.length > 0) { playerPicksUpPile(PLAYER_NAME); } }
          };

          const showStartScreen = () => {
            term.clear();
            term.print("=== SHITHEAD CARD GAME ===");
            term.print("Goal: Be the first to get rid of all your cards.\n");
            term.print("Rules: Play an equal or higher card. 2 resets the pile, 10 burns it.");
            term.print("Controls:\n  Number keys: Select a card to play\n  T: Take the pile\n  Alt+Q: Quit game\n");
            term.print("Press any key to start...");
            document.addEventListener('keydown', function startHandler(e) {
              e.preventDefault(); e.stopImmediatePropagation(); this.removeEventListener('keydown', startHandler);
              inputLine.style.display = 'none';
              document.addEventListener('keydown', masterInputHandler, { capture: true });
              createNewGame();
              draw();
            }, { once: true });
          };

          showStartScreen();
        });
      }
    }
  };
  SystemPrograms.push(shitheadProgram);
  // -------- END PROGRAM: SHITHEAD --------

  // -------- START PROGRAM: BREAKOUT --------
  const breakoutProgram = {
    name: 'breakout',
    program: {
      description: 'Smash bricks with the ball in this arcade classic.',
      execute: async (term) => {
        return new Promise(resolve => {
          const WIDTH = 50, HEIGHT = 24;
          const PADDLE_WIDTH = 10;
          const BRICK_COLORS = ['var(--green-3)', 'var(--green-4)', 'var(--green-5)', 'var(--green-6)'];
          let paddle, ball, bricks, score, lives, gameState;
          let keys = {};
          let gameLoopId = null;

          const initGame = () => {
            gameState = 'running';
            score = 0; lives = 3;
            paddle = { x: (WIDTH - PADDLE_WIDTH) / 2 };
            resetBall(); createBricks();
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            gameLoop();
          };

          const resetBall = () => { ball = { x: WIDTH / 2, y: HEIGHT - 3, dx: Math.random() > 0.5 ? 0.4 : -0.4, dy: -0.25 }; };
          const createBricks = () => {
            bricks = [];
            const brickRows = 4, brickCols = 10;
            const brickWidth = WIDTH / brickCols;
            for (let r = 0; r < brickRows; r++) { for (let c = 0; c < brickCols; c++) { bricks.push({ x: c * brickWidth, y: r + 2, width: brickWidth, alive: true, color: BRICK_COLORS[r % BRICK_COLORS.length] }); } }
          };

          const handleKeyDown = (e) => { keys[e.key] = true; };
          const handleKeyUp = (e) => { keys[e.key] = false; };

          const update = () => {
            if (gameState !== 'running') return;
            if (keys['ArrowLeft'] && paddle.x > 0) paddle.x -= 1;
            if (keys['ArrowRight'] && paddle.x < WIDTH - PADDLE_WIDTH) paddle.x += 1;

            ball.x += ball.dx; ball.y += ball.dy;

            if (ball.x <= 0 || ball.x >= WIDTH - 1) ball.dx *= -1;
            if (ball.y <= 0) ball.dy *= -1;

            if (ball.y >= HEIGHT - 1) {
              lives--;
              if (lives <= 0) { gameState = 'gameOver'; }
              else { resetBall(); }
            }

            const ballFloorY = Math.floor(ball.y);
            if (ballFloorY === HEIGHT - 2 && ball.dy > 0 && ball.x >= paddle.x && ball.x < paddle.x + PADDLE_WIDTH) {
              ball.dy *= -1;
              let hitPos = (ball.x - (paddle.x + PADDLE_WIDTH / 2)) / (PADDLE_WIDTH / 2); // -1 to 1
              ball.dx = hitPos * 0.5; // Scale paddle influence for more controlled speed
            }

            for (const brick of bricks) {
              if (brick.alive && Math.floor(ball.y) === Math.floor(brick.y) && ball.x >= brick.x && ball.x < brick.x + brick.width) {
                brick.alive = false;
                ball.dy *= -1;
                score += 10;
              }
            }
            if (bricks.every(b => !b.alive)) { gameState = 'win'; }
          };

          const draw = () => {
            term.clear();
            let grid = Array.from({ length: HEIGHT }, () => Array(WIDTH).fill(' '));
            for (const brick of bricks) { if (brick.alive) { for (let i = 0; i < Math.floor(brick.width); i++) { if (Math.floor(brick.x) + i < WIDTH) grid[Math.floor(brick.y)][Math.floor(brick.x) + i] = `<span style="color:${brick.color}">‚ñì</span>`; } } }
            for (let i = 0; i < PADDLE_WIDTH; i++) { if (Math.floor(paddle.x) + i < WIDTH) grid[HEIGHT - 2][Math.floor(paddle.x) + i] = '‚ñÄ'; }
            if (Math.floor(ball.y) >= 0 && Math.floor(ball.y) < HEIGHT && Math.floor(ball.x) >= 0 && Math.floor(ball.x) < WIDTH) {
                grid[Math.floor(ball.y)][Math.floor(ball.x)] = 'O';
            }
            let output = grid.map(row => row.join('')).join('\n');
            output += `\nScore: ${score} | Lives left: ${'‚ô•'.repeat(lives)}`;
            if (gameState === 'gameOver') { output += "\n\n  GAME OVER!"; }
            else if (gameState === 'win') { output += "\n\n  YOU WON! CONGRATULATIONS!"; }
            term.print(output);
          };

          const gameLoop = () => {
            if (gameState === 'gameOver' || gameState === 'win' || gameState === 'exit') {
              draw();
              exitGame(gameState === 'exit' ? "Breakout exited by user." : null);
              return;
            }
            update();
            draw();
            gameLoopId = requestAnimationFrame(gameLoop);
          };

          const exitGame = (message) => {
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            document.removeEventListener('keydown', masterInputHandler, { capture: true });
            if (message) term.print("\n" + message);
            term.print("\nTo play again, type 'breakout' and press Enter.");
            document.querySelector('.input-line').style.display = 'flex';
            resolve();
          };

          const masterInputHandler = (e) => { if (e.altKey && e.key.toLowerCase() === 'q') { e.preventDefault(); e.stopImmediatePropagation(); gameState = 'exit'; } };

          const showStartScreen = () => {
            term.clear();
            term.print("=== BREAKOUT ===");
            term.print("Smash all the bricks with the ball to win.\n");
            term.print("Controls:\n  Left/Right Arrow: Steer the paddle\n  Alt+Q: Quit game\n");
            term.print("Press any key to start...");
            document.addEventListener('keydown', function startHandler(e) {
              e.preventDefault(); e.stopImmediatePropagation();
              this.removeEventListener('keydown', startHandler);
              document.querySelector('.input-line').style.display = 'none';
              document.addEventListener('keydown', masterInputHandler, { capture: true });
              initGame();
            }, { once: true });
          };

          showStartScreen();
        });
      }
    }
  };
  SystemPrograms.push(breakoutProgram);
  // -------- END PROGRAM: BREAKOUT --------



// -------- START PROGRAM: SOKOBAN --------
  const sokobanProgram = {
    name: 'sokoban',
    program: {
      description: 'A classic box-pushing puzzle game.',
      execute: async (term) => {
        return new Promise(resolve => {
          const inputLine = document.querySelector('.input-line');

          // --- 100 Classic Sokoban Levels (Verified Count) ---
          const LEVELS = [
            ["  #####","  #   #","  #$  #","###  $##","#  $ $ #","### # ## #   ######","#   # ## #####  ..#","# $  $          ..#","##### ### #@##  ..#","    #     #########","    #######"],
            ["############","#..  #     #","#..  # $ $ #","#..  #$#### #","#..    @ # #","#..  # #  $#","###### ##$ #","  # $  $ # #","  #    #   #","  ##########"],
            ["        ########","        #     @#","        # $#$ ##","        # $  #","      ####$  #","      #   #$ #","####### ###$ #","#... #    #  #","##...#  $ #  #"," #...#$#$ #  #"," ####### ##  #","       #     #","       #######"],
            ["    #####","    #   #","    #   #","  ###$###","  #  $  #","### # ###","# @ #$# #","##$.#$# #","# #$# ###","# #.# ###","#.#.#   #","#########"],
            ["  ########","###  ##  #","#  $ ##$ #","# $     @#","##$##. ###","# # .#  #","# # ..# #","#########"],
            ["    ######","#####  #@#","# $ ##$# #","# #  .#  #","###$#$ . #","  # $ .$ #","  #  .   #","  ########"],
            ["##########","#    #   #","# #$## #$#","# # ## # #","#   .  @ #","##$###$###","#.# #  # #","#.#    # #","##########"],
            ["   #######","   #  ...#","   # #$# #","   # # ###","#### #@# ####","# $# # # #  #","#  # # # #$ #","# $#   #   #","####$#####$#","   #     #","   #######"],
            ["        #####","        #   #","        #$  #","        #   #","      ###$#####","      #  $  ..#","    ###$  $ ..#","    #@ $# $ ..#","    #  #  #####","    #   #","    #####"],
            ["#######","#  # @#","# $#$ #","#  #$ #","# $#$ #","## #  ##","#.####.#","#....#.#","########"],
            ["  #####"," ##   #"," #  # # ##","#  $$#$@ #","# #.# #  #","###.##.###"," #.#  .# #"," # ## #  #"," #     #"," #######"],
            ["  ######","  # @  #","  #$## #"," ## . #"," # $.# #"," # #$# #"," # # ###","## # # ##","#  $ # #","#    # #","########"],
            ["    #####","    #@  #","  ### $ #","  #  .# #"," ##$#$# #","  #.$#$ #","  # $ . #","  #  ####","  ####"],
            ["    #####","#####   #","#   #$# #","# @$ .  #","### $#$##","# # .# #","# #$.# #","#   #  #","########"],
            ["  ######","  #    #"," ##$#$ #","#@ $.# #","# $$#$ #","###. .##","  # ##","  #  #","  ####"],
            ["########","#@ #   #","#  ##$##","# #  $ #","# #  $ #","# ##.###","#  $.#","#    .#","########"],
            ["  ######","# ## @ #","# # $  #","# #$## #","#  ..# #","##$##$##","# #  # #","#      #","########"],
            ["  ########","#  #  @  #","# #$##$# #","# #    # #","#  $## ##","# ##..$#","# #..# #","#      #","########"],
            [" #####"," #   #","# #$#@#","# ... #","##$#$##","# # # #","#     #","#######"],
            ["  ######","  # @  #","  #    #"," ##$## #","# #.$ #","# $.$ #","##   ##"," #   #"," #####"],
            ["  ######"," ##@   #"," # $## #","# #.$ #","# $.# #","# # # #","#   $ #","#######"],
            ["    #####","    #@  #","    # $ #","  ### ###","# #$#$.#","# # ###","#.#.  #","# $####","##   #"," #   #"," #####"],
            ["  ######"," ##@   #"," # $## #","# $.# #","# #$# #","# #.# #","#  $# #","#    #","######"],
            ["  ####","  # @#"," ##$ #"," # $.#","# #$#","# #$#","#.#.#","#   #","######"],
            [" #####"," # @ #","# #$#","# $ #","#$.#","# # #","#   #","#####"],
            ["  ####","#  @ #","# #$##","# $. #","# #$ #","##.###"," # #","# #","# #"," # #"," ###"],
            [" #####"," # @ #","# #$#","# $.#","# # ##","#   #","#   #","#####"],
            [" #####","# @ #","# #$#","# .$#","# ##","# #","# #","###"],
            [" ####","#@ #","# $##","# .$#","# # #","#   #","#####"],
            ["  #####","#   @ #","#  #$##","# #$. #","# #$# #","# # # #","## .# ##"," #   #","#    #","######"],
            [" #####","#   #","# #@#","# $##","#$.#","# #","# #","###"],
            [" #####","# @ #","# #$##","# .$#","# # #","# # #","## ##"," # #"," ###"],
            ["  ####","#  @#","# #$#","# $.#","##$##","# # #","# # #","## ##"," # #"," ###"],
            [" #####","#  @#","# #$#","# .$#","#$ ##","# #","# #","###"],
            ["  ####","#  @ #","# #$##","# .$#","## ##","# #","# #","# #","###"],
            ["  ####","# @#","#$ #","# .#","# ##","# #","###"],
            ["#####","#@  #","#$# #","#.# #","# $ #","## ##"," #  #"," ####"],
            [" ####","# @ #","#$# #","#.# #","# $#","## #"," # #"," ###"],
            [" #####","#   #","# #@#","# $$##","#..#","#  ##","#####"],
            [" ####","#  #","# @#","#$##","#..#","#$ #","####"],
            ["  ####","#   @#","#  #$#","## #.#","# $#.#","###  #","  #  #","  ####"],
            ["  #####","# @   #","# #$# #","## #$##","# #..#","#   ##","######"],
            ["  #####","#     #","# #@# #","## $$ #","#..#  #","##   ##","######"],
            [" ######","#      #","# #@## #","##$# # #","#.. $  #","## # ###"," #### #","    ###"],
            ["   #####","   #   #","####@# #","## $   #","# #.## #","# #.# $#","# #.#  #","###  ###","  #  #","  ####"],
            ["  ######","#      #","##@#$# #"," # #.. #"," # #$# #"," #  $# #"," ####  #","    ####"],
            ["  ######","#   @  #","## ##$ #","# # ..#","# #$# ##","#  $#  #","## #  ##"," #####"],
            [" ######","# #    #","# $# @ #","#  #$# #","##.#. ##","# #.$# #","# $  # #","###  ###"],
            ["    ######","    #    #","  ###$## #"," ## $ @# #","#  #$ # #","# .#.# #","###$ .# #","  #  .  #","  #######"],
            ["   ######","#   #  #","# $ #$ #","# @$.  #","########"," # # #","# # .#","#     #","#######"],
            ["  #####","  #   #","###$# #","# $  @#","# #$###","# #.#","#...#","#####"],
            ["######","#    #","# #$@#","# #$##","# #..#","#  $ #","######"],
            ["    #####","    #   #","  ###@# #","  # $ # #"," ##$### #","# # ..##","# #$#  #","#   #  #","########"],
            ["   ######","#   #  #","# $ @$ #","#  #$ ##","##.#.  #","# #.$# #","# $  # #","###  ###"],
            ["     #####"," #####   #"," #  @#$# #"," # # $ . #","## #$###.#"," # #   ..#"," # # #####"," #   #"," #####"],
            ["  ######","#      #","## # ## #"," #$#$@ #","##.#  ##","# #.$#","# # ##","#   #","#####"],
            ["######","#    #","# #@##","# $# #","#$.# #","##$# #"," #   #"," #####"],
            ["  ######","#   @  #","##$##$ #","# # .. #","##$## ##","# # #  #","#   #  #","########"],
            ["######","#    #","##@#$#","# $#.#","#  #.#","#  $ #","######"],
            ["   #####","   #   #"," ###@# #"," # $ #$#","## #.  #"," # #.# #"," #  . $#"," ######"],
            ["   ######","#      #","# # #$@#","# $# # ##","#  .#  #","##$#.# #"," #   $ #"," #######"],
            ["   ######","#      #","# #@#$ #","# $# # ##","#  .#$ #","##$#.# #"," #     #"," #######"],
            ["    #####","    #   #","  ###@# #"," ## $#$ #","# #..  #","# #$## #","#    # #","########"],
            ["  #######","  #  #  #"," ##$@$ #"," #.#.#.#"," # $ $ #"," ##   ##","  #   #","  #####"],
            [" #####","#     #","# #@# #","## #$##","# #..#","#  $#","#  #","#  #","####"],
            ["    ######","    # @  #","  ###$## #","  # $# # #"," ##$#$ # #","# # . .  #","# # #####","###$#   #","#   ####","#######"],
            ["   #######","#   #     #","# $ # ### #","# @#$  $# #","#####$##  #","  #.#  #$ #","  #.#    #","  #  #####","  ####"],
            ["######","#@   #","# $#$#","#  #.#","##$# #"," #.# ##"," # $# #"," #  # #"," #   #"," #####"],
            ["######","#@#  #","#$#$ #","# #.##","# $..#","## # #","#  # #","######"],
            ["  ######","#  # @ #","# #$#$ #","## #..##","#  $ # #","##$# # #"," #   # #"," ##### #","     ###"],
            ["######","# @  #","#$##$#","# .#.#","# #$ #","### ##","#   #","#####"],
            ["  #######","  #     #"," ##@#$# ##","  #$.#  #"," ##$##$#","  # ..# #","  #  #  #","  #######"],
            ["#######","#  #  #","# @$.#","#$#$.#","# #$.#","# $$##","#  #","#  #","####"],
            ["#######","# # # #","# #$# #","#  @..#","#####$##","  # $  #","  #  # #","  #    #","  ######"],
            ["#######","#  #  #","# @$.#","#$#$.#","# #$.#","# #$##","#  $ #","######"],
            ["   #######","#       #","# ####### #","##$## $## #","#  $@ $  #","# ##.##.##","# #..##..#","# #  ##  #","#          #","############"],
            ["  ######","#  # @ #","# #$#$ #","## #.##","# #..# #","# $# # #","###  # #","  #    #","  ######"],
            ["#######","#     #","# ### #","# # @ #","# #$# #","# #$# #","#.#.#.#","##   ##"],
            ["#######","#     #","# #####","# #   #","# #$@$#","# #. .#","# # ## ","#   #"],
            ["    #####","    #   #","    #@  #","  ###$###","# #$# #.#","# # # #.#","## .# #$##"," # $ # . #"," #   #   #"," #########"],
            ["  #######","# #  #  #","# $#@$# #","# . . . #","###########","# # # # # #","#         #","#########"],
            ["    #####","    #   #","    #@# #","     $# #","    #$# #","    #.#.#","    ##.##"],
            ["  ######","#  @   #","# #$## #","## #$# #","# #.. $#","# $# # #","#  #   #","########"],
            ["   ######","#   @  #","# $ #$ #","#  #$ ##","##$#.# #","# .#..#","# # # ##","###   #"],
            ["    #####","    # @ #","    #$# #","  ###$###","# # . . #","# #$#$# #","## # # ##","#  $   #","#    # #","########"],
            ["  ######","#  # @ #","# #$#$ #","## #.##","# #$ # #","#  . # #","### ## #","  #    #","  ######"],
            ["    #####","    #   #","    #@# #","     $# #","    #$# #","    #.#.#","    ##.##","     # #","     # #","     ###"],
            ["   ######","#   @  #","# $ #$ #","#  #$.##","##$#.# #","# .#..#","# # # ##","###   #"],
            ["  #######","  #  @  #"," ##$#$##","  #.#.#","# #$#$# #","## # # ##"," #   # #"," #######"],
            ["    #####","    #   #","    #@# #","   #$#$ #","  ## # ##","  #..# #"," ##$#$##","# # # #","# #   #","#     #","#######"],
            ["    #####","  ###   #","  # @$# #"," ### # ##","#.# # $#","#.# $ $#","#.#   ##","# ### #","## $  #"," #   ##"," #####"],
            ["    #####","    #   #","    #@  #","   #$####","  ##$#..#","  # # ..#"," ##$# ##","# # ##","# #   #","#     #","#######"],
            [" #####","#  #  #","# @#$ #","# $..#","## ##$#"," #  #.#","# $#$# #","#   # #","#######"],
            ["     #####"," ##### @ #","# $  #$# #","# # ##.#.#","###$#$#..#","  #   #..#","  #   ######","  #   #","  #####"],
            ["   #######","#   #  #  #","# $#@$#$ #","#  .#....#","##$###$####"," # # #   #"," #   #####"," #####"],
            ["    #####","    #   #","  ###@# #"," ## $#$ #","# #.$..#","# #$# ##","# #  #","#    #","######"],
            ["   #######","   #     #","   # #$# #","   # # ###","#### #@# ####","# $# # # #  #","#  # # # #$ #","# $#   #   #","####$#####$#","   #     #","   #######"],
            ["    #####","    #   #","    #@  #","  ###$###","# #$# #.#","# # # #.#","## .# #$##"," # $ # . #"," #   #   #"," #########","     #   #","     #####"]
        ];

          let level, player, boxes, targets, walls, moves, undoStack, gameState;
          let currentLevelIndex = 0;

          const isWall = (x, y) => walls.some(w => w.x === x && w.y === y);
          const getBoxAt = (x, y) => boxes.find(b => b.x === x && b.y === y);
          const isTarget = (x, y) => targets.some(t => t.x === x && t.y === y);

          const loadLevel = (levelIndex) => {
            level = LEVELS[levelIndex].map(row => row.split(''));
            player = {}; boxes = []; targets = []; walls = [];
            moves = 0; undoStack = []; gameState = 'playing';

            for (let y = 0; y < level.length; y++) {
              for (let x = 0; x < level[y].length; x++) {
                switch (level[y][x]) {
                  case '@': player = { x, y }; break;
                  case '+': player = { x, y }; targets.push({ x, y }); break;
                  case '$': boxes.push({ x, y }); break;
                  case '*': boxes.push({ x, y }); targets.push({ x, y }); break;
                  case '.': targets.push({ x, y }); break;
                  case '#': walls.push({ x, y }); break;
                }
              }
            }
            draw();
          };

          const checkWin = () => {
              if (boxes.length === 0 || targets.length === 0) return false;
              for (const target of targets) {
                  if (!getBoxAt(target.x, target.y)) return false;
              }
              return true;
          };

          const movePlayer = (dx, dy) => {
            if (gameState !== 'playing') return;

            const nextX = player.x + dx;
            const nextY = player.y + dy;

            if (isWall(nextX, nextY)) return;

            const box = getBoxAt(nextX, nextY);
            if (box) {
              const boxNextX = nextX + dx;
              const boxNextY = nextY + dy;
              if (isWall(boxNextX, boxNextY) || getBoxAt(boxNextX, boxNextY)) return;

              undoStack.push({ player: { ...player }, boxes: boxes.map(b => ({ ...b })) });
              box.x = boxNextX;
              box.y = boxNextY;
            } else {
               undoStack.push({ player: { ...player }, boxes: boxes.map(b => ({ ...b })) });
            }

            player.x = nextX;
            player.y = nextY;
            moves++;

            if (checkWin()) {
                gameState = 'win';
                draw();
                setTimeout(() => {
                    currentLevelIndex++;
                    if (currentLevelIndex < LEVELS.length) {
                        loadLevel(currentLevelIndex);
                    } else {
                        exitGame('Congratulations! You have completed all 100 levels!');
                    }
                }, 2000);
            } else {
                draw();
            }
          };

          const undo = () => {
            if (undoStack.length > 0) {
                const lastState = undoStack.pop();
                player = lastState.player;
                boxes = lastState.boxes;
                moves--;
                draw();
            }
          };

          const draw = () => {
              term.clear();
              let output = '';
              const maxY = level.length;
              const maxX = Math.max(...level.map(r => r.length));

              for (let y = 0; y < maxY; y++) {
                  let line = '';
                  for (let x = 0; x < maxX; x++) {
                      if (player.x === x && player.y === y) {
                          line += isTarget(x,y) ? '+' : '@';
                      } else if (getBoxAt(x, y)) {
                          line += isTarget(x,y) ? '*' : '$';
                      } else if (isWall(x, y)) {
                          line += '#';
                      } else if (isTarget(x,y)) {
                          line += '.';
                      } else {
                          line += ' ';
                      }
                  }
                  output += line + '\n';
              }
              output += '\n--- SOKOBAN ---\n';
              const boxesOnTarget = targets.filter(t => getBoxAt(t.x, t.y)).length;
              output += `Level: ${currentLevelIndex + 1}/${LEVELS.length} | Moves: ${moves} | Targets: ${boxesOnTarget}/${targets.length}\n`;
              output += `(WASD/Arrows) Move | (R) Restart | (U) Undo | (Alt+Q) Quit\n`;
              if (gameState === 'win') {
                  output += '\nLevel Complete!';
              }
              term.print(output);
          };

          const exitGame = (message) => {
            document.removeEventListener('keydown', masterInputHandler, { capture: true });
            term.clear();
            if (message) term.print(message);
            term.print("\nTo play again, type 'sokoban' and press Enter.");
            inputLine.style.display = 'flex';
            resolve();
          };

          const masterInputHandler = (e) => {
            if (e.altKey && e.key.toLowerCase() === 'q') { e.preventDefault(); e.stopImmediatePropagation(); exitGame("Sokoban exited by user."); return; }
            e.preventDefault(); e.stopImmediatePropagation();

            switch (e.key.toLowerCase()) {
              case 'w': case 'arrowup': movePlayer(0, -1); break;
              case 'a': case 'arrowleft': movePlayer(-1, 0); break;
              case 's': case 'arrowdown': movePlayer(0, 1); break;
              case 'd': case 'arrowright': movePlayer(1, 0); break;
              case 'r': loadLevel(currentLevelIndex); break;
              case 'u': undo(); break;
            }
          };

          inputLine.style.display = 'none';
          document.addEventListener('keydown', masterInputHandler, { capture: true });
          loadLevel(currentLevelIndex);
        });
      }
    }
  };
  SystemPrograms.push(sokobanProgram);
  // -------- END PROGRAM: SOKOBAN --------



  // -------- START PROGRAM: EDIT --------
  const editProgram = {
    name: 'edit',
    program: {
      description: 'A full-featured text and code editor with templates.',
      execute: async (term) => {
        return new Promise(resolve => {
          const CONTAINER_ID = 'editor-container-dynamic', STYLE_ID = 'editor-style-dynamic', EDITOR_ID = 'editor-textarea-dynamic', SEARCH_MODAL_ID = 'search-modal-dynamic';
          const shortcuts = [ { key: 'Ctrl + O', desc: 'Open file' }, { key: 'Ctrl + S', desc: 'Save file' }, { key: 'Alt + N', desc: 'New file (with WebDOS template)' }, { key: 'Alt + S', desc: 'Search & replace' }, { key: 'Alt + P', desc: 'Preview HTML' }, { key: 'Tab', desc: 'Indent' }, { key: 'Shift+Tab', desc: 'Outdent' }, { key: 'Alt + Q', desc: 'Quit editor' } ];
          term.print("--- Code Editor Shortcuts ---");
          shortcuts.forEach(s => term.print(`${s.key.padEnd(15, ' ')}: ${s.desc}`));
          term.print("\nPress any key to start the editor...");

          let hasUnsavedChanges = false;

          const exitEditor = () => {
            document.removeEventListener('keydown', masterKeyHandler, true);
            window.removeEventListener('beforeunload', beforeUnloadHandler);
            document.getElementById(CONTAINER_ID)?.remove();
            document.getElementById(STYLE_ID)?.remove();
            document.querySelector('.input-line').style.display = 'flex';
            resolve();
          };

          const beforeUnloadHandler = (e) => { if(hasUnsavedChanges) { e.preventDefault(); e.returnValue = ''; } };
          const masterKeyHandler = (e) => {
             // Prioritize the quit command above all else
            if (e.altKey && e.key.toLowerCase() === 'q') {
              e.preventDefault();
              e.stopImmediatePropagation();
              if (hasUnsavedChanges && !confirm("You have unsaved changes. Quit anyway?")) {
                  return;
              }
              exitEditor();
              return;
            }
            // Dispatch other keys to the editor's internal handler
            document.dispatchEvent(new CustomEvent('editor-global-keydown', { detail: e }));
          };

          const setupAndRun = () => {
            document.querySelector('.input-line').style.display = 'none';
            const style = document.createElement('style'); style.id = STYLE_ID;
            style.textContent = `#${CONTAINER_ID}{position:fixed;top:0;left:0;width:100%;height:100%;z-index:100}#${EDITOR_ID}{width:100%;height:100%;box-sizing:border-box;border:none;outline:none;resize:none;white-space:pre;overflow-wrap:normal;overflow:auto;background-color:var(--black);color:var(--green-6);font-family:'Menlo','Monaco','Courier New',monospace;font-size:16px;padding:10px;caret-color:var(--green-7)}.${SEARCH_MODAL_ID}-class{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:400px;background-color:var(--black);border:2px solid var(--green-5);color:var(--green-6);z-index:110;padding:20px;box-shadow:0 0 20px rgba(88,222,17,.3)}.editor-modal-close-btn{position:absolute;top:10px;right:15px;font-size:24px;color:var(--green-6);cursor:pointer;background:0 0;border:none}#${SEARCH_MODAL_ID} h2{margin-top:0;text-align:left}#${SEARCH_MODAL_ID} .input-group{margin-bottom:15px}#${SEARCH_MODAL_ID} label{display:block;margin-bottom:5px}#${SEARCH_MODAL_ID} #match-count{float:right;font-size:.8em;color:var(--green-4)}#${SEARCH_MODAL_ID} input{width:100%;background-color:var(--green-0);border:1px solid var(--green-5);color:var(--green-6);padding:5px;box-sizing:border-box}#${SEARCH_MODAL_ID} .button-group{display:flex;justify-content:space-between;gap:10px}#${SEARCH_MODAL_ID} button{flex-grow:1;background:0 0;border:1px solid var(--green-5);color:var(--green-5);padding:8px;cursor:pointer}#${SEARCH_MODAL_ID} button:hover{background-color:var(--green-5);color:var(--black)}`;
            document.head.appendChild(style);
            const container = document.createElement('div'); container.id = CONTAINER_ID;
            container.innerHTML = `<textarea id="${EDITOR_ID}" spellcheck="false" autofocus></textarea><div id="${SEARCH_MODAL_ID}" class="${SEARCH_MODAL_ID}-class"><button id="search-close" class="editor-modal-close-btn">&times;</button><h2>Search & Replace</h2><div class="input-group"><label for="find-input">Find: <span id="match-count"></span></label><input type="text" id="find-input"></div><div class="input-group"><label for="replace-input">Replace with:</label><input type="text" id="replace-input"></div><div class="button-group"><button id="find-next-btn">Find Next</button><button id="replace-btn">Replace</button><button id="replace-all-btn">Replace All</button></div></div>`;
            document.body.appendChild(container);
            initEditorLogic();
            document.addEventListener('keydown', masterKeyHandler, true);
            window.addEventListener('beforeunload', beforeUnloadHandler);
          };

          const initEditorLogic = () => {
            const editor = document.getElementById(EDITOR_ID);
            const searchModal = document.getElementById(SEARCH_MODAL_ID);
            const findInput = document.getElementById('find-input');
            let currentFileHandle = null;

            const newFile = () => {
              if (hasUnsavedChanges && !confirm("Unsaved changes will be lost. Continue?")) return;
              const template = `
const myNewProgram = {
  name: 'myname',
  program: {
    description: 'A short description of the program.',
    execute: async (term) => {
      return new Promise(resolve => {
        term.print("My new program is running!");

        const exitProgram = () => {
          // Cleanup logic, if any, goes here.
          resolve();
        };

        exitProgram();
      });
    }
  }
};
SystemPrograms.push(myNewProgram);`;
              editor.value = template.trim(); currentFileHandle = null; hasUnsavedChanges = false; editor.focus();
              const cursorPos = template.indexOf('myname');
              editor.setSelectionRange(cursorPos, cursorPos + 'myname'.length);
            };

            const saveFile = async () => { if (!currentFileHandle) { try { currentFileHandle = await window.showSaveFilePicker({ suggestedName: 'program.js' }); } catch (err) { return; } } try { const writable = await currentFileHandle.createWritable(); await writable.write(editor.value); await writable.close(); hasUnsavedChanges = false; } catch(err) { console.error(err); } };
            const openFile = async () => { if (hasUnsavedChanges && !confirm("Unsaved changes will be lost. Continue?")) return; try { const [fileHandle] = await window.showOpenFilePicker(); const file = await fileHandle.getFile(); editor.value = await file.text(); currentFileHandle = fileHandle; hasUnsavedChanges = false; } catch (err) {} };
            const previewCode = () => { const win = window.open(); win.document.write(editor.value); win.document.close(); };
            const toggleSearch = () => { searchModal.style.display = searchModal.style.display === 'block' ? 'none' : 'block'; if(searchModal.style.display === 'block') findInput.focus(); else editor.focus(); };

            editor.addEventListener('input', () => { hasUnsavedChanges = true; });
            editor.addEventListener('keydown', e => { if (e.key === 'Tab') { e.preventDefault(); document.execCommand('insertText', false, '  '); } });
            document.getElementById('search-close').addEventListener('click', toggleSearch);

            document.addEventListener('editor-global-keydown', e => {
              const originalEvent = e.detail;
              if(searchModal.style.display === 'block') { if(originalEvent.key === 'Escape') toggleSearch(); return; }
              const isCtrl = originalEvent.ctrlKey || originalEvent.metaKey;
              const key = originalEvent.key.toLowerCase();
              if(isCtrl && key === 's') { originalEvent.preventDefault(); saveFile(); }
              if(isCtrl && key === 'o') { originalEvent.preventDefault(); openFile(); }
              if(originalEvent.altKey && key === 'n') { originalEvent.preventDefault(); newFile(); }
              if(originalEvent.altKey && key === 'p') { originalEvent.preventDefault(); previewCode(); }
              if(originalEvent.altKey && key === 's') { originalEvent.preventDefault(); toggleSearch(); }
            });

            editor.focus();
          };

          document.addEventListener('keydown', function startHandler(e) { e.preventDefault(); e.stopImmediatePropagation(); this.removeEventListener('keydown', startHandler); setupAndRun(); }, { once: true });
        });
      }
    }
  };
  SystemPrograms.push(editProgram);
  // -------- END PROGRAM: EDIT --------


// -------- START PROGRAM: LUNARLANDER --------
  const lunarlanderProgram = {
    name: 'lunarlander',
    program: {
      description: 'Land the lunar module safely on the moon.',
      execute: async (term) => {
        return new Promise(resolve => {
          // --- Game Config ---
          const WIDTH = 70, HEIGHT = 24, SCORES_KEY = 'webdos_lunarlander_highscores';
          const GRAVITY = 0.001, MAIN_THRUST = -0.0025, SIDE_THRUST = 0.0015;
          const SAFE_LANDING_SPEED_V = 0.1, SAFE_LANDING_SPEED_H = 0.15;

          const COLORS = { HUD_SAFE: 'var(--green-5)', HUD_WARN: 'var(--green-6)', HUD_DANGER: 'var(--green-7)', TERRAIN: 'var(--green-4)', PAD: 'var(--green-6)', LANDER: 'var(--green-7)', FLAME: 'var(--green-6)'};
          const CHARS = { LANDER: 'V', TERRAIN: '‚ñà', MAIN_FLAME: '‚ñ≤', SIDE_FLAME_L: '>', SIDE_FLAME_R: '<' };

          // --- Game State ---
          let lander, terrain, landingPad, gameState, gameLoopId, level, totalScore;
          let keys = {};

          const inputLine = document.querySelector('.input-line');

          const getHighScores = () => { try { const scores = localStorage.getItem(SCORES_KEY); return scores ? JSON.parse(scores) : []; } catch (e) { return []; } };
          const saveHighScore = (newScore) => { if (newScore === 0) return; const scores = getHighScores(); scores.push({ score: newScore, date: new Date().toLocaleDateString() }); scores.sort((a, b) => b.score - a.score); localStorage.setItem(SCORES_KEY, JSON.stringify(scores.slice(0, 3))); };

          const startLevel = () => {
            generateTerrain();
            lander = { x: WIDTH / 2, y: 5, vx: 0.05 * (1 + level/10), vy: 0, fuel: 750 };
            gameState = 'running';
            // If the loop isn't running, start it.
            if (!gameLoopId) {
              gameLoopId = requestAnimationFrame(gameLoop);
            }
          };

          const runGame = () => {
            level = 1;
            totalScore = 0;
            startLevel();
          };

          const generateTerrain = () => {
              terrain = [];
              let currentY = HEIGHT - 5;
              for(let i = 0; i < WIDTH; i++) {
                  if (Math.random() > 0.6) currentY += (Math.random() > 0.5 ? 1 : -1);
                  currentY = Math.max(HEIGHT - 10, Math.min(HEIGHT - 2, currentY));
                  terrain.push(currentY);
              }
              const padWidth = Math.max(4, 9 - Math.floor(level / 2));
              const padStartIndex = Math.floor(10 + Math.random() * (WIDTH - padWidth - 20));
              const padY = terrain[padStartIndex + Math.floor(padWidth/2)];
              for(let i=0; i<padWidth; i++) {
                  terrain[padStartIndex + i] = padY;
              }
              landingPad = { startX: padStartIndex, endX: padStartIndex + padWidth, y: padY };
          };

          const handleKeyDown = (e) => { keys[e.key.toLowerCase()] = true; };
          const handleKeyUp = (e) => { keys[e.key.toLowerCase()] = false; };

          const exitGame = () => {
            if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; }
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            document.removeEventListener('keydown', masterInputHandler, { capture: true });
            term.print("\nTo play again, type 'lunarlander' and press Enter.");
            inputLine.style.display = 'flex';
            resolve();
          };

          const update = () => {
            if (gameState !== 'running') return;
            lander.vy += GRAVITY;
            if (lander.fuel > 0) {
                if (keys['w'] || keys['arrowup']) { lander.vy += MAIN_THRUST; lander.fuel -= 1; }
                if (keys['a'] || keys['arrowleft']) { lander.vx -= SIDE_THRUST; lander.fuel -= 0.2; }
                if (keys['d'] || keys['arrowright']) { lander.vx += SIDE_THRUST; lander.fuel -= 0.2; }
            }
            if (lander.fuel < 0) lander.fuel = 0;
            lander.x += lander.vx; lander.y += lander.vy;

            const landerRoundX = Math.round(lander.x);
            const groundY = landerRoundX >= 0 && landerRoundX < WIDTH ? terrain[landerRoundX] : HEIGHT;

            if (lander.y >= groundY -1) {
                lander.y = groundY - 1;
                const onPad = landerRoundX >= landingPad.startX && landerRoundX <= landingPad.endX;
                const safeV = Math.abs(lander.vy) < SAFE_LANDING_SPEED_V;
                const safeH = Math.abs(lander.vx) < SAFE_LANDING_SPEED_H;

                if(onPad && safeV && safeH) gameState = 'landed';
                else gameState = 'crashed';
            }
          };

          const draw = (message) => {
            term.clear();
            let grid = Array.from({ length: HEIGHT }, () => Array(WIDTH).fill(' '));
            for(let x=0; x<WIDTH; x++){
                const color = (x >= landingPad.startX && x <= landingPad.endX) ? COLORS.PAD : COLORS.TERRAIN;
                for(let y=terrain[x]; y<HEIGHT; y++) grid[y][x] = `<span style="color:${color}">${CHARS.TERRAIN}</span>`;
            }

            const landerRoundX = Math.round(lander.x), landerRoundY = Math.round(lander.y);
            if (landerRoundY >= 0 && landerRoundY < HEIGHT && landerRoundX >= 0 && landerRoundX < WIDTH) {
                grid[landerRoundY][landerRoundX] = `<span style="color:${COLORS.LANDER}">${CHARS.LANDER}</span>`;
                if(lander.fuel > 0 && gameState === 'running') {
                    if ((keys['w'] || keys['arrowup']) && landerRoundY + 1 < HEIGHT) grid[landerRoundY + 1][landerRoundX] = `<span style="color:${COLORS.FLAME}">${CHARS.MAIN_FLAME}</span>`;
                    if ((keys['a'] || keys['arrowleft']) && landerRoundX + 1 < WIDTH) grid[landerRoundY][landerRoundX + 1] = `<span style="color:${COLORS.FLAME}">${CHARS.SIDE_FLAME_L}</span>`;
                    if ((keys['d'] || keys['arrowright']) && landerRoundX - 1 >= 0) grid[landerRoundY][landerRoundX - 1] = `<span style="color:${COLORS.FLAME}">${CHARS.SIDE_FLAME_R}</span>`;
                }
            }

            const groundY = terrain[landerRoundX] || HEIGHT;
            const altitude = Math.max(0, groundY - lander.y - 1);
            const vSpeedColor = Math.abs(lander.vy) < SAFE_LANDING_SPEED_V ? COLORS.HUD_SAFE : (Math.abs(lander.vy) < SAFE_LANDING_SPEED_V * 2 ? COLORS.HUD_WARN : COLORS.HUD_DANGER);
            const hSpeedColor = Math.abs(lander.vx) < SAFE_LANDING_SPEED_H ? COLORS.HUD_SAFE : (Math.abs(lander.vx) < SAFE_LANDING_SPEED_H * 2 ? COLORS.HUD_WARN : COLORS.HUD_DANGER);
            const fuelColor = lander.fuel > 300 ? COLORS.HUD_SAFE : (lander.fuel > 100 ? COLORS.HUD_WARN : COLORS.HUD_DANGER);
            const fuelBar = '‚ñà'.repeat(Math.ceil(lander.fuel / 37.5)) + '‚ñë'.repeat(20 - Math.ceil(lander.fuel / 37.5));

            let output = grid.map(row => row.join('')).join('\n');
            output += `\nLVL: ${level} | ALT: ${altitude.toFixed(2).padStart(7,' ')}m | `;
            output += `V SPD: <span style="color:${vSpeedColor}">${lander.vy.toFixed(2).padStart(5,' ')}</span> | `;
            output += `H SPD: <span style="color:${hSpeedColor}">${lander.vx.toFixed(2).padStart(5,' ')}</span> | `;
            output += `FUEL: <span style="color:${fuelColor}">[${fuelBar}]</span>`;
            output += `\nSCORE: ${totalScore}`;

            if (message) output += `\n\n${message}`;
            term.print(output);
          };

          const gameLoop = () => {
            update();

            if (gameState === 'running') {
                draw();
                gameLoopId = requestAnimationFrame(gameLoop);
            } else {
                gameLoopId = null; // Stop the loop
                if (gameState === 'landed') {
                    const fuelBonus = Math.round(lander.fuel);
                    const speedBonus = Math.round((SAFE_LANDING_SPEED_V - Math.abs(lander.vy)) * 1000 + (SAFE_LANDING_SPEED_H - Math.abs(lander.vx)) * 500);
                    const levelScore = fuelBonus + speedBonus + (level * 250);
                    totalScore += levelScore;
                    level++;
                    let nextLevelMessage = `<span style="background-color:${COLORS.PAD}; color:var(--black);">-- LEVEL ${level-1} COMPLETE! | +${levelScore} pts --</span>`;
                    nextLevelMessage += `\nPreparing next descent...`;
                    draw(nextLevelMessage);
                    setTimeout(startLevel, 3000);
                } else { // Crashed
                    saveHighScore(totalScore);
                    const highScores = getHighScores();
                    let finalMessage = `<span style="background-color:${COLORS.HUD_DANGER}; color:var(--black);">-- GAME OVER | FINAL SCORE: ${totalScore} --</span>\n\n--- Top Scores ---\n`;
                    highScores.forEach((s, i) => { finalMessage += `${i+1}. ${s.score} (${s.date})\n`; });
                    draw(finalMessage);
                    setTimeout(exitGame, 4000);
                }
            }
          };

          const masterInputHandler = (e) => { if (e.altKey && e.key.toLowerCase() === 'q') { e.preventDefault(); e.stopImmediatePropagation(); gameState = 'exit'; saveHighScore(totalScore); exitGame("Lunar Lander exited by user."); } };

          const showStartScreen = () => {
            term.clear();
            term.print("=== LUNAR LANDER ===");
            term.print("Safely land the module on the highlighted landing pad.\n");
            term.print("Controls:\n  W/Up Arrow:    Main Thruster\n  A,D/Left,Right: Side Thrusters\n  Alt+Q:          Quit Game\n");
            const highScores = getHighScores();
            if(highScores.length > 0) {
                term.print("--- Top Scores ---");
                highScores.forEach((s,i) => term.print(`${i+1}. ${s.score} (${s.date})`));
            }
            term.print("\nPress any key to begin...");
            document.addEventListener('keydown', function startHandler(e) {
              e.preventDefault(); e.stopImmediatePropagation();
              this.removeEventListener('keydown', startHandler);
              inputLine.style.display = 'none';
              document.addEventListener('keydown', handleKeyDown);
              document.addEventListener('keyup', handleKeyUp);
              document.addEventListener('keydown', masterInputHandler, { capture: true });
              runGame();
            }, { once: true });
          };

          showStartScreen();
        });
      }
    }
  };
  SystemPrograms.push(lunarlanderProgram);
  // -------- END PROGRAM: LUNARLANDER --------


  // --- Main Terminal Logic ---
  const terminalEl = document.getElementById('terminal');
  const inputLine = document.querySelector('.input-line');
  const inputBuffer = document.getElementById('input-buffer');
  const commandHistory = [];
  let historyIndex = -1;
  let commandBuffer = '';
  let isAppRunning = false;

  const programs = {};
  SystemPrograms.forEach(p => { if (p && p.name && p.program) { programs[p.name] = p.program; } });

  const terminal = {
    print: (message, options = {}) => {
      const newLine = document.createElement('div');
      if (options.commandText !== undefined) {
        newLine.classList.add('output-line', 'input-line');
        const promptSpan = document.createElement('span'); promptSpan.className = 'prompt'; promptSpan.textContent = message;
        const commandSpan = document.createElement('span'); commandSpan.className = 'input-text'; commandSpan.textContent = options.commandText;
        newLine.appendChild(promptSpan); newLine.appendChild(commandSpan);
      } else {
        newLine.classList.add('output-line');
        newLine.innerHTML = message;
        if (options.color && !message.includes('<span')) newLine.style.color = options.color;
        if (options.backgroundColor) { newLine.style.backgroundColor = options.backgroundColor; newLine.style.padding = '0 0.5ch'; }
      }
      terminalEl.insertBefore(newLine, inputLine);
      window.scrollTo(0, document.body.scrollHeight);
    },
    clear: () => {
      terminalEl.querySelectorAll('.output-line').forEach(line => line.remove());
    }
  };

  async function processCommand(command) {
    const [cmd, ...args] = command.trim().split(' ');
    const cmdLower = cmd.toLowerCase();
    if (!cmdLower) return;
    commandHistory.push(command);
    historyIndex = commandHistory.length;

    const aliases = { 'clear': 'clear', 'cls': 'clear', 'help': 'help', '?': 'help', 'echo': 'echo', 'dir': 'dir', 'ls': 'dir' };
    const resolvedCmd = aliases[cmdLower] || cmdLower;

    if (resolvedCmd in programs) {
      isAppRunning = true;
      try { await programs[resolvedCmd].execute(terminal, args); }
      catch (error) { terminal.print(`Error in '${cmdLower}': ${error.message}`); }
      finally { isAppRunning = false; }
      return;
    }

    switch (resolvedCmd) {
      case 'clear': terminal.clear(); break;
      case 'help':
        terminal.print('Core commands: clear, help, echo, dir');
        terminal.print('Aliases: cls, ?, ls\n');
        terminal.print('Type "dir" to see a list of available programs.');
        break;
      case 'echo': terminal.print(args.join(' ')); break;
      case 'dir':
        terminal.print('Contents of C:\\\n');
        const programNames = Object.keys(programs).sort();
        programNames.forEach(pName => {
          const description = programs[pName].description || '';
          terminal.print(`${pName.padEnd(15, ' ')}${description}`);
        });
        terminal.print(`\n\t${programNames.length} Program(s)`);
        break;
      default: terminal.print(`Invalid command or file name: '${cmd}'`);
    }
  }

  function updateInput() {
    inputBuffer.textContent = commandBuffer;
    window.scrollTo(0, document.body.scrollHeight);
  }

  document.addEventListener('keydown', async (e) => {
    if (isAppRunning) return;
    if (['Enter', 'Backspace', 'ArrowUp', 'ArrowDown'].includes(e.key)) e.preventDefault();
    if (e.key === 'Enter') {
      terminal.print(`C:\\>`, { commandText: commandBuffer });
      const commandToProcess = commandBuffer;
      commandBuffer = '';
      updateInput();
      await processCommand(commandToProcess);
    } else if (e.key === 'Backspace') {
      commandBuffer = commandBuffer.slice(0, -1);
    } else if (e.key === 'ArrowUp') {
      if (historyIndex > 0) { historyIndex--; commandBuffer = commandHistory[historyIndex]; }
    } else if (e.key === 'ArrowDown') {
      if (historyIndex < commandHistory.length - 1) { historyIndex++; commandBuffer = commandHistory[historyIndex]; }
      else { historyIndex = commandHistory.length; commandBuffer = ''; }
    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
      commandBuffer += e.key;
    }
    updateInput();
  });

  terminal.print('WebDOS [Version 1.0]');
  terminal.print("Type 'help' for a list of commands.");

</script>
</body>
</html>