<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebDOS</title>
  <style>
    :root {
      --black: #000000;
      --green: var(--green-7);
      --green-0: #051a00;
      --green-1: #133b03;
      --green-2: #215b06;
      --green-3: #2e7c09;
      --green-4: #3c9d0b;
      --green-5: #4ab50e;
      --green-6: #58de11;
      --green-7: #65ff14;
    }
    html,
    body {
      margin: 0;
      padding: 0;
      background-color: var(--black);
      color: var(--green);
      font-family: 'Courier New', Courier, monospace;
      font-size: 20px;
    }
    #terminal {
      padding: 10px;
    }
    .output-line {
      white-space: pre-wrap;
    }
    .input-line {
      display: flex;
      align-items: center;
      height: 1.2em;
    }
    .prompt {
      flex-shrink: 0;
    }
    .input-text {
      padding-right: 1ch;
      white-space: pre;
    }
    #cursor {
      display: inline-block;
      background-color: var(--green);
      width: 1ch;
      height: 0.9em;
      animation: blink 1s step-end infinite;
      margin-left: -1ch;
      margin-bottom: 0.2ch;
    }
    @keyframes blink {
      from,
      to {
        background-color: transparent;
      }
      50% {
        background-color: var(--green);
      }
    }
  </style>
</head>
<body>
  <div id="terminal">
    <div class="input-line">
      <span class="prompt">C:\&gt;</span>
      <span id="input-buffer" class="input-text"></span>
      <span id="cursor"></span>
    </div>
  </div>
  <script>
    const SystemPrograms = [];

    // -------- START PROGRAM: ABOUT --------
    const aboutProgram = {
      name: 'about',
      program: {
        description: 'Prints information about this system.',
        execute: async (term) => {
          term.print("WebDOS [Version 1.0]");
          term.print("(c) 2025. A self-contained terminal environment.");
        }
      }
    };
    SystemPrograms.push(aboutProgram);
    // -------- END PROGRAM: ABOUT --------

    // -------- START PROGRAM: COLORS --------
    const colorsProgram = {
      name: 'colors',
      program: {
        description: 'Displays all 8 colors in the system palette.',
        execute: async (term) => {
          term.print('--- Testing the system 8-color palette ---');
          for (let i = 0; i <= 7; i++) {
            const colorVar = `var(--green-${i})`;
            term.print(`Sample text in --green-${i}`, { color: colorVar });
          }
          term.print('--- End of palette ---', {
            color: 'var(--black)',
            backgroundColor: 'var(--green-7)'
          });
        }
      }
    };
    SystemPrograms.push(colorsProgram);
    // -------- END PROGRAM: COLORS --------

    // -------- START PROGRAM: TETRIS --------
    const tetrisProgram = {
      name: 'tetris',
      program: {
        description: 'A classic block-stacking game.',
        execute: async (term) => {
          return new Promise(resolve => {
            const BOARD_WIDTH = 10, BOARD_HEIGHT = 20, SCORES_KEY = 'webdos_tetris_highscores';
            const COLORS = { BORDER: 'var(--green-4)', SCORE_TEXT: 'var(--green-6)', LOCKED_PIECE: 'var(--green-5)', GHOST_PIECE: 'var(--green-3)', ACTIVE_PIECE: 'var(--green-7)', GAME_OVER: 'var(--green-7)' };
            const PIECES = { 'I': [[1, 1, 1, 1]], 'O': [[1, 1], [1, 1]], 'T': [[0, 1, 0], [1, 1, 1]], 'L': [[0, 0, 1], [1, 1, 1]], 'J': [[1, 0, 0], [1, 1, 1]], 'S': [[0, 1, 1], [1, 1, 0]], 'Z': [[1, 1, 0], [0, 1, 1]] };
            const PIECE_TYPES = 'IOTLJSZ';

            let board, score, lines, gameOver, currentPiece, nextPiece, gameLoopId, gameState = 'start';
            const inputLine = document.querySelector('.input-line');

            const getHighScores = () => { try { const scores = localStorage.getItem(SCORES_KEY); return scores ? JSON.parse(scores) : []; } catch (e) { return []; } };
            const saveHighScore = (newScore) => { if (newScore === 0) return; const scores = getHighScores(); scores.push({ score: newScore, date: new Date().toLocaleDateString() }); scores.sort((a, b) => b.score - a.score); localStorage.setItem(SCORES_KEY, JSON.stringify(scores.slice(0, 10))); };
            
            const exitGame = (message) => {
              if (gameLoopId) cancelAnimationFrame(gameLoopId);
              document.removeEventListener('keydown', masterInputHandler, { capture: true });
              term.clear();
              if (message) term.print(message);
              inputLine.style.display = 'flex';
              resolve();
            };

            const createEmptyBoard = () => Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0));
            const spawnPiece = () => { currentPiece = nextPiece; const type = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)]; nextPiece = { shape: PIECES[type], x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 }; if (checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y)) { gameOver = true; } };
            const checkCollision = (shape, x, y) => { for (let row = 0; row < shape.length; row++) { for (let col = 0; col < shape[row].length; col++) { if (shape[row][col]) { let boardX = x + col; let boardY = y + row; if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT || (boardY >= 0 && board[boardY][boardX])) { return true; } } } } return false; };
            const rotatePiece = () => { const shape = currentPiece.shape; const newShape = shape[0].map((_, colIndex) => shape.map(row => row[colIndex]).reverse()); if (!checkCollision(newShape, currentPiece.x, currentPiece.y)) { currentPiece.shape = newShape; } };
            const lockPiece = () => { currentPiece.shape.forEach((row, y) => { row.forEach((value, x) => { if (value && (currentPiece.y + y) >= 0) { board[currentPiece.y + y][currentPiece.x + x] = 1; } }); }); };
            
            const clearLines = () => {
              let linesCleared = 0;
              for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                  linesCleared++;
                  board.splice(y, 1);
                  board.unshift(Array(BOARD_WIDTH).fill(0));
                  y++;
                }
              }
              if (linesCleared > 0) {
                lines += linesCleared;
                score += (linesCleared * 100) * linesCleared;
              }
            };
            
            const getGhostPosition = () => { let ghostY = currentPiece.y; while (!checkCollision(currentPiece.shape, currentPiece.x, ghostY + 1)) { ghostY++; } return ghostY; };
            
            const draw = () => {
              term.clear();
              const ghostY = getGhostPosition();
              const outputBuffer = [];
              outputBuffer.push(`<span style="color:${COLORS.BORDER}">‚ïî${'‚ïê‚ïê'.repeat(BOARD_WIDTH)}‚ïó</span>`);
              for (let y = 0; y < BOARD_HEIGHT; y++) {
                let line = `<span style="color:${COLORS.BORDER}">‚ïë</span>`;
                for (let x = 0; x < BOARD_WIDTH; x++) {
                  const pieceX = x - currentPiece.x, pieceY = y - currentPiece.y, ghostPieceY = y - ghostY;
                  const isPiece = pieceY >= 0 && pieceY < currentPiece.shape.length && pieceX >= 0 && pieceX < currentPiece.shape[pieceY].length && currentPiece.shape[pieceY][pieceX];
                  const isGhost = ghostPieceY >= 0 && ghostPieceY < currentPiece.shape.length && pieceX >= 0 && pieceX < currentPiece.shape[ghostPieceY].length && currentPiece.shape[ghostPieceY][pieceX];
                  if (isPiece) { line += `<span style="color:${COLORS.ACTIVE_PIECE}">‚ñà‚ñà</span>`; } 
                  else if (isGhost) { line += `<span style="color:${COLORS.GHOST_PIECE}">‚ñë‚ñë</span>`; } 
                  else if (board[y][x]) { line += `<span style="color:${COLORS.LOCKED_PIECE}">‚ñì‚ñì</span>`; } 
                  else { line += '  '; }
                }
                line += `<span style="color:${COLORS.BORDER}">‚ïë</span>`;
                outputBuffer.push(line);
              }
              outputBuffer.push(`<span style="color:${COLORS.BORDER}">‚ïö${'‚ïê‚ïê'.repeat(BOARD_WIDTH)}‚ïù</span>`);
              outputBuffer.push(`<span style="color:${COLORS.SCORE_TEXT}">  Score: ${score}   Lines: ${lines}</span>`);
              outputBuffer.push(`<span style="color:${COLORS.SCORE_TEXT}">  Next:</span>`);
              if (nextPiece && nextPiece.shape) {
                nextPiece.shape.forEach(row => {
                  const nextPieceLine = '  ' + row.map(cell => cell ? '‚ñà‚ñà' : '  ').join('');
                  outputBuffer.push(`<span style="color:${COLORS.ACTIVE_PIECE}">${nextPieceLine}</span>`);
                });
              }
              term.print(outputBuffer.join('\n'));
            };
            
            const masterInputHandler = (e) => {
              if (e.altKey && e.key.toLowerCase() === 'q') { e.preventDefault(); e.stopImmediatePropagation(); exitGame("Tetris exited by user."); return; }
              e.stopImmediatePropagation();
              switch (gameState) {
                case 'start': e.preventDefault(); gameState = 'playing'; runGame(); break;
                case 'playing':
                  if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', ' '].includes(e.key)) e.preventDefault();
                  if (e.key === 'ArrowLeft') { if (!checkCollision(currentPiece.shape, currentPiece.x - 1, currentPiece.y)) currentPiece.x--; } 
                  else if (e.key === 'ArrowRight') { if (!checkCollision(currentPiece.shape, currentPiece.x + 1, currentPiece.y)) currentPiece.x++; } 
                  else if (e.key === 'ArrowDown') { if (!checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) { currentPiece.y++; score += 1; } else { lockPiece(); clearLines(); spawnPiece(); } } 
                  else if (e.key === 'ArrowUp') { rotatePiece(); } 
                  else if (e.key === ' ') { const ghostY = getGhostPosition(); score += (ghostY - currentPiece.y) * 2; currentPiece.y = ghostY; lockPiece(); clearLines(); spawnPiece(); }
                  draw(); 
                  break;
              }
            };
            
            const showStartScreen = () => {
              term.clear();
              term.print("=== TETRIS ===", { color: COLORS.SCORE_TEXT });
              term.print("Controls:\n  Left/Right: Move\n  Up: Rotate\n  Down: Soft drop\n  Spacebar: Hard drop\n  Alt+Q: Force quit\n");
              term.print("Top 10 High Scores:");
              const highScores = getHighScores();
              if (highScores.length === 0) { term.print("  No high scores yet. Be the first!"); }
              else { highScores.forEach((s, i) => term.print(`${(i + 1).toString().padStart(2)}. ${s.score.toString().padStart(6, ' ')} (${s.date})`)); }
              term.print("\nPress any key to start...");
            };
            
            const runGame = () => {
              board = createEmptyBoard(); score = 0; lines = 0; gameOver = false;
              const firstType = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
              nextPiece = { shape: PIECES[firstType], x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 };
              spawnPiece();
              let lastTime = 0; let dropCounter = 0;
              const gameLoop = (time = 0) => {
                if (gameOver) {
                  saveHighScore(score);
                  term.print(`\n<span style='color: ${COLORS.GAME_OVER};'>Game Over!</span>`);
                  term.print("To play again, type 'tetris' and press Enter.");
                  cancelAnimationFrame(gameLoopId);
                  document.removeEventListener('keydown', masterInputHandler, { capture: true });
                  inputLine.style.display = 'flex';
                  resolve(); return;
                }
                const deltaTime = time - lastTime; lastTime = time; dropCounter += deltaTime;
                if (dropCounter > 1000) { if (checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) { lockPiece(); clearLines(); spawnPiece(); } else { currentPiece.y++; } dropCounter = 0; }
                draw();
                gameLoopId = requestAnimationFrame(gameLoop);
              };
              gameLoop();
            };
            
            inputLine.style.display = 'none';
            document.addEventListener('keydown', masterInputHandler, { capture: true });
            showStartScreen();
          });
        }
      }
    };
    SystemPrograms.push(tetrisProgram);
    // -------- END PROGRAM: TETRIS --------

    // -------- START PROGRAM: SNAKE --------
    const snakeProgram = {
      name: 'snake',
      program: {
        description: 'A classic snake game. The speed increases!',
        execute: async (term) => {
          return new Promise(resolve => {
            const BOARD_WIDTH = 25, BOARD_HEIGHT = 18, SCORES_KEY = 'webdos_snake_highscores';
            const COLORS = { BORDER: 'var(--green-4)', SCORE_TEXT: 'var(--green-6)', SNAKE_HEAD: 'var(--green-7)', SNAKE_BODY: 'var(--green-5)', FOOD: 'var(--green-6)', GAME_OVER: 'var(--green-7)' };
            const CHARS = { SNAKE_HEAD: '‚ñà‚ñà', SNAKE_BODY: '‚ñì‚ñì', FOOD: '‚ñà‚ñà' };
            let snake, food, score, gameOver, direction, gameLoopId, gameState = 'start', gameSpeed;
            const inputLine = document.querySelector('.input-line');
            const getHighScores = () => { try { const scores = localStorage.getItem(SCORES_KEY); return scores ? JSON.parse(scores) : []; } catch (e) { return []; } };
            const saveHighScore = (newScore) => { if (newScore === 0) return; const scores = getHighScores(); scores.push({ score: newScore, date: new Date().toLocaleDateString() }); scores.sort((a, b) => b.score - a.score); localStorage.setItem(SCORES_KEY, JSON.stringify(scores.slice(0, 10))); };
            
            const exitGame = (message) => {
              if (gameLoopId) clearTimeout(gameLoopId);
              document.removeEventListener('keydown', masterInputHandler, { capture: true });
              term.clear();
              if (message) term.print(message);
              inputLine.style.display = 'flex';
              resolve();
            };
            
            const placeFood = () => {
              while (true) {
                food = { x: Math.floor(Math.random() * BOARD_WIDTH), y: Math.floor(Math.random() * BOARD_HEIGHT) };
                if (!snake.some(segment => segment.x === food.x && segment.y === food.y)) break;
              }
            };
            
            const initGame = () => {
              snake = [{ x: Math.floor(BOARD_WIDTH / 2), y: Math.floor(BOARD_HEIGHT / 2) }];
              direction = { x: 0, y: 0 };
              score = 0; gameOver = false; gameSpeed = 150; // Start speed
              gameState = 'playing';
              placeFood();
              gameLoop();
            };
            
            const draw = () => {
              term.clear();
              const outputBuffer = [];
              outputBuffer.push(`<span style="color:${COLORS.BORDER}">‚ïî${'‚ïê‚ïê'.repeat(BOARD_WIDTH)}‚ïó</span>`);
              for (let y = 0; y < BOARD_HEIGHT; y++) {
                let line = `<span style="color:${COLORS.BORDER}">‚ïë</span>`;
                for (let x = 0; x < BOARD_WIDTH; x++) {
                  const isHead = snake[0].x === x && snake[0].y === y;
                  const isBody = snake.slice(1).some(seg => seg.x === x && seg.y === y);
                  const isFood = food.x === x && food.y === y;
                  if (isHead) line += `<span style="color:${COLORS.SNAKE_HEAD}">${CHARS.SNAKE_HEAD}</span>`;
                  else if (isBody) line += `<span style="color:${COLORS.SNAKE_BODY}">${CHARS.SNAKE_BODY}</span>`;
                  else if (isFood) line += `<span style="color:${COLORS.FOOD}">${CHARS.FOOD}</span>`;
                  else line += '  ';
                }
                line += `<span style="color:${COLORS.BORDER}">‚ïë</span>`;
                outputBuffer.push(line);
              }
              outputBuffer.push(`<span style="color:${COLORS.BORDER}">‚ïö${'‚ïê‚ïê'.repeat(BOARD_WIDTH)}‚ïù</span>`);
              outputBuffer.push(`<span style="color:${COLORS.SCORE_TEXT}">  Score: ${score} | Speed: ${((150 / gameSpeed - 1) * 100 + 100).toFixed(0)}%</span>`);
              term.print(outputBuffer.join('\n'));
            };
            
            const masterInputHandler = (e) => {
              if (e.altKey && e.key.toLowerCase() === 'q') { e.preventDefault(); e.stopImmediatePropagation(); exitGame("Snake exited by user."); return; }
              e.stopImmediatePropagation(); e.preventDefault();
              if (gameState === 'start') { initGame(); return; }
              if (gameState === 'playing') {
                switch (e.key) {
                  case 'ArrowUp': if (direction.y === 0) direction = { x: 0, y: -1 }; break;
                  case 'ArrowDown': if (direction.y === 0) direction = { x: 0, y: 1 }; break;
                  case 'ArrowLeft': if (direction.x === 0) direction = { x: -1, y: 0 }; break;
                  case 'ArrowRight': if (direction.x === 0) direction = { x: 1, y: 0 }; break;
                }
              }
            };
            
            const showStartScreen = () => {
              term.clear();
              term.print("=== SNAKE ===", { color: COLORS.SCORE_TEXT });
              term.print("Controls:\n  Arrow keys: Steer the snake\n  Alt+Q: Force quit\n");
              term.print("Top 10 High Scores:");
              const highScores = getHighScores();
              if (highScores.length === 0) { term.print("  No high scores yet. Be the first!"); } 
              else { highScores.forEach((s, i) => term.print(`${(i + 1).toString().padStart(2)}. ${s.score.toString().padStart(6, ' ')} (${s.date})`)); }
              term.print("\nPress any key to start...");
            };
            
            const gameLoop = () => {
              if (gameOver) {
                saveHighScore(score);
                term.print(`\n<span style='color: ${COLORS.GAME_OVER};'>Game Over!</span>`);
                term.print("To play again, type 'snake' and press Enter.");
                document.removeEventListener('keydown', masterInputHandler, { capture: true });
                inputLine.style.display = 'flex';
                resolve(); return;
              }
              const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
              if (head.x < 0 || head.x >= BOARD_WIDTH || head.y < 0 || head.y >= BOARD_HEIGHT) gameOver = true;
              if (snake.slice(1).some(seg => seg.x === head.x && seg.y === head.y)) gameOver = true;
              if (direction.x !== 0 || direction.y !== 0) {
                snake.unshift(head);
                if (head.x === food.x && head.y === food.y) {
                  score += 10;
                  gameSpeed = Math.max(40, gameSpeed * 0.97); // Increase speed!
                  placeFood();
                } else {
                  snake.pop();
                }
              }
              draw();
              gameLoopId = setTimeout(gameLoop, gameSpeed);
            };
            
            inputLine.style.display = 'none';
            document.addEventListener('keydown', masterInputHandler, { capture: true });
            showStartScreen();
          });
        }
      }
    };
    SystemPrograms.push(snakeProgram);
    // -------- END PROGRAM: SNAKE --------

    // -------- START PROGRAM: IDIOT --------
    const idiotProgram = {
      name: 'idiot',
      program: {
        description: 'The classic card game Idiot. Get rid of your cards!',
        execute: async (term) => {
          return new Promise(resolve => {
            const PLAYER_NAME = "You", AI_NAME = "The Machine", CARD_RANKS = { '3': 1, '4': 2, '5': 3, '6': 4, '7': 5, '8': 6, '9': 7, 'J': 8, 'Q': 9, 'K': 10, 'A': 11, '2': 12, '10': 13 };
            let gameState = {};
            const inputLine = document.querySelector('.input-line');
            const getCardValue = (card) => (card ? card.slice(0, -1) : ''), getCardRank = (card) => card ? CARD_RANKS[getCardValue(card)] || 0 : 0, sortCards = (cards) => cards.sort((a, b) => getCardRank(a) - getCardRank(b));
            
            const createNewGame = () => {
              const suits = ['H', 'D', 'C', 'S'], values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
              let deck = [];
              for (const suit of suits) { for (const value of values) { deck.push(value + suit); } }
              for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[deck[i], deck[j]] = [deck[j], deck[i]]; }
              gameState = {
                players: {
                  [PLAYER_NAME]: { name: PLAYER_NAME, hand: sortCards(deck.splice(0, 3)), faceUp: sortCards(deck.splice(0, 3)), faceDown: deck.splice(0, 3) },
                  [AI_NAME]: { name: AI_NAME, hand: sortCards(deck.splice(0, 3)), faceUp: sortCards(deck.splice(0, 3)), faceDown: deck.splice(0, 3) },
                },
                deck: deck, discardPile: [], turn: PLAYER_NAME, winner: null, gameInProgress: true, statusMessage: `The game has started. It's your turn!`
              };
            };
            
            const switchTurn = () => {
              if (gameState.winner) return;
              gameState.turn = gameState.turn === PLAYER_NAME ? AI_NAME : PLAYER_NAME;
              gameState.statusMessage = `It's ${gameState.players[gameState.turn].name}'s turn.`;
              draw();
              if (gameState.turn === AI_NAME) setTimeout(aiTurn, 1200);
            };
            
            const drawCards = (player) => { const p = gameState.players[player]; while (p.hand.length < 3 && gameState.deck.length > 0) p.hand.push(gameState.deck.pop()); sortCards(p.hand); };
            const checkWinCondition = (player) => { const p = gameState.players[player]; if (p.hand.length === 0 && p.faceUp.length === 0 && p.faceDown.length === 0) { gameState.winner = player; gameState.gameInProgress = false; return true; } return false; };
            const checkFourOfAKind = () => { if (gameState.discardPile.length < 4) return false; const topFour = gameState.discardPile.slice(-4); return topFour.every(c => getCardValue(c) === getCardValue(topFour[0])); };
            
            const burnPile = (player) => {
              gameState.statusMessage = `${gameState.players[player].name} burned the pile! New turn.`;
              draw();
              setTimeout(() => { gameState.discardPile = []; drawCards(player); if (checkWinCondition(player)) { endGame(); return; } draw(); if (player === AI_NAME) setTimeout(aiTurn, 1000); }, 800);
            };
            
            const processMove = (player, card, sourcePile) => {
              const source = gameState.players[player][sourcePile];
              const index = source.indexOf(card); if (index > -1) source.splice(index, 1);
              gameState.discardPile.push(card);
              gameState.statusMessage = `${gameState.players[player].name} played ${formatCard(card)}.`;
              if (checkWinCondition(player)) { endGame(); return; }
              if (checkFourOfAKind()) { burnPile(player); return; }
              const cardValue = getCardValue(card);
              if (cardValue === '10') { burnPile(player); return; }
              if (cardValue === '2') { gameState.statusMessage = `The pile was reset.`; }
              drawCards(player);
              if (checkWinCondition(player)) { endGame(); return; }
              switchTurn();
            };
            
            const getEffectiveTopCard = () => { for (let i = gameState.discardPile.length - 1; i >= 0; i--) { if (getCardValue(gameState.discardPile[i]) !== '2') return gameState.discardPile[i]; } return null; };
            const checkMoveLegality = (cardToPlay) => { const cardValue = getCardValue(cardToPlay); if (cardValue === '2' || cardValue === '10' || gameState.discardPile.length === 0) return true; const effectiveTopCard = getEffectiveTopCard(); if (!effectiveTopCard) return true; return getCardRank(cardToPlay) >= getCardRank(effectiveTopCard); };
            const playerPicksUpPile = (player) => { if (gameState.discardPile.length === 0) { switchTurn(); return; } const p = gameState.players[player]; p.hand.push(...gameState.discardPile); sortCards(p.hand); gameState.discardPile = []; gameState.statusMessage = `${p.name} picked up the pile.`; switchTurn(); };
            
            const handlePlayerMove = (card, sourcePile) => {
              if (sourcePile !== 'faceDown' && !checkMoveLegality(card)) { gameState.statusMessage = "Invalid move! Play a higher card or take the pile."; draw(); return; }
              if (sourcePile === 'faceDown') {
                if (checkMoveLegality(card)) { gameState.statusMessage = `You played ${formatCard(card)} blind... It was legal!`; processMove(PLAYER_NAME, card, 'faceDown'); } 
                else { gameState.statusMessage = `You played ${formatCard(card)} blind... Unlucky!`; const source = gameState.players[PLAYER_NAME].faceDown; const index = source.indexOf(card); if (index > -1) source.splice(index, 1); gameState.discardPile.push(card); draw(); setTimeout(() => playerPicksUpPile(PLAYER_NAME), 800); }
              } else { processMove(PLAYER_NAME, card, sourcePile); }
            };
            
            const aiTurn = () => {
              if (gameState.turn !== AI_NAME || !gameState.gameInProgress) return;
              const ai = gameState.players[AI_NAME];
              const playableFrom = ai.hand.length > 0 ? 'hand' : ai.faceUp.length > 0 ? 'faceUp' : 'faceDown';
              const cardOptions = ai[playableFrom];
              if (playableFrom === 'faceDown') {
                const cardToPlay = cardOptions[0];
                gameState.statusMessage = `${AI_NAME} is playing blind...`; draw();
                setTimeout(() => { if (checkMoveLegality(cardToPlay)) { processMove(AI_NAME, cardToPlay, 'faceDown'); } else { const source = gameState.players[AI_NAME].faceDown; const index = source.indexOf(cardToPlay); if (index > -1) source.splice(index, 1); gameState.discardPile.push(cardToPlay); playerPicksUpPile(AI_NAME); } }, 500); return;
              }
              const legalMoves = cardOptions.filter(checkMoveLegality);
              if (legalMoves.length === 0) { playerPicksUpPile(AI_NAME); return; }
              const tens = legalMoves.filter(c => getCardValue(c) === '10'); if (tens.length > 0 && gameState.discardPile.length >= 5) { processMove(AI_NAME, tens[0], playableFrom); return; }
              let normalMoves = legalMoves.filter(c => !['2', '10'].includes(getCardValue(c))); if (normalMoves.length > 0) { processMove(AI_NAME, normalMoves[0], playableFrom); return; }
              processMove(AI_NAME, legalMoves[0], playableFrom);
            };
            
            const formatCard = (cardStr) => { if (!cardStr) return '[   ]'; const suitSymbols = { H: '‚ô•', D: '‚ô¶', C: '‚ô£', S: '‚ô†' }; const value = getCardValue(cardStr).padEnd(2); const suit = suitSymbols[cardStr.slice(-1)]; return `[${value}${suit}]`; };
            const draw = () => {
              term.clear();
              const p = gameState.players[PLAYER_NAME], ai = gameState.players[AI_NAME];
              let out = [];
              out.push(`${AI_NAME} (Hand: ${ai.hand.length}, Face-Up: ${ai.faceUp.length}, Face-Down: ${ai.faceDown.length})`);
              out.push(`  Face-Up: ${ai.faceUp.map(formatCard).join(' ')}`);
              out.push(`  Face-Down: ${ai.faceDown.map(() => '[??]').join(' ')}`);
              out.push('');
              out.push('‚îÄ'.repeat(50));
              const topCard = gameState.discardPile.length > 0 ? formatCard(gameState.discardPile[gameState.discardPile.length - 1]) : '[   ]';
              out.push(`Deck: ${gameState.deck.length > 0 ? '[??]' : '[  ]'} (${gameState.deck.length})       Pile: ${topCard} (${gameState.discardPile.length})`);
              out.push('‚îÄ'.repeat(50));
              out.push('');
              const activePile = p.hand.length > 0 ? p.hand : p.faceUp.length > 0 ? p.faceUp : p.faceDown;
              let handStr = p.hand.length > 0 ? `Your Hand:` : p.faceUp.length > 0 ? `Your Face-Up Cards:` : `Your Face-Down Cards:`;
              out.push(`${PLAYER_NAME} (Your turn!)`);
              out.push(`  Face-Up: ${p.faceUp.map(formatCard).join(' ')}`);
              out.push(`  Face-Down: ${p.faceDown.map(() => '[??]').join(' ')}`);
              out.push(`${handStr} ${activePile.map((c, i) => `${i + 1}:${p.hand.length > 0 || p.faceUp.length > 0 ? formatCard(c) : '[??]'}`).join('   ')}`);
              out.push('\n');
              out.push(`Status: ${gameState.statusMessage}`);
              let controls = `Controls: Select card (1-${activePile.length})`;
              const canPlay = activePile.some(checkMoveLegality) || activePile === p.faceDown;
              if (!canPlay && gameState.discardPile.length > 0) controls += ", (T)ake pile";
              controls += ', (Alt+Q) Quit';
              out.push(controls);
              term.print(out.join('\n'));
            };
            
            const endGame = () => { gameState.statusMessage = gameState.winner === PLAYER_NAME ? `üéâ YOU WON! ${AI_NAME} is the Idiot!` : `üò≠ YOU LOST! You are the Idiot!`; draw(); setTimeout(() => { term.print("\nType 'idiot' to play again."); exitGame(); }, 2000); };
            const exitGame = () => { document.removeEventListener('keydown', masterInputHandler, { capture: true }); inputLine.style.display = 'flex'; resolve(); };
            
            const masterInputHandler = (e) => {
              if (!gameState.gameInProgress || (gameState.turn !== PLAYER_NAME)) return;
              if (e.altKey && e.key.toLowerCase() === 'q') { e.preventDefault(); e.stopImmediatePropagation(); exitGame("Idiot exited by user."); return; }
              e.preventDefault(); e.stopImmediatePropagation();
              const p = gameState.players[PLAYER_NAME];
              const activePile = p.hand.length > 0 ? p.hand : p.faceUp.length > 0 ? p.faceUp : p.faceDown;
              const activePileName = p.hand.length > 0 ? 'hand' : p.faceUp.length > 0 ? 'faceUp' : 'faceDown';
              if (!isNaN(e.key) && e.key > 0 && e.key <= activePile.length) { handlePlayerMove(activePile[parseInt(e.key) - 1], activePileName); } 
              else if (e.key.toLowerCase() === 't') { if (!activePile.some(checkMoveLegality) && gameState.discardPile.length > 0) { playerPicksUpPile(PLAYER_NAME); } }
            };
            
            const showStartScreen = () => {
              term.clear();
              term.print("=== IDIOT CARD GAME ===");
              term.print("Goal: Be the first to get rid of all your cards.\n");
              term.print("Rules: Play an equal or higher card. 2 resets the pile, 10 burns it.");
              term.print("Controls:\n  Number keys: Select a card to play\n  T: Take the pile\n  Alt+Q: Quit game\n");
              term.print("Press any key to start...");
              document.addEventListener('keydown', function startHandler(e) {
                e.preventDefault(); e.stopImmediatePropagation(); this.removeEventListener('keydown', startHandler);
                inputLine.style.display = 'none';
                document.addEventListener('keydown', masterInputHandler, { capture: true });
                createNewGame();
                draw();
              }, { once: true });
            };
            
            showStartScreen();
          });
        }
      }
    };
    SystemPrograms.push(idiotProgram);
    // -------- END PROGRAM: IDIOT --------
    
    // -------- START PROGRAM: BREAKOUT --------
    const breakoutProgram = {
      name: 'breakout',
      program: {
        description: 'Smash bricks with the ball in this arcade classic.',
        execute: async (term) => {
          return new Promise(resolve => {
            // --- GAME CONFIG ---
            const WIDTH = 50, HEIGHT = 24;
            const PADDLE_WIDTH = 10;
            const BRICK_COLORS = ['var(--green-3)', 'var(--green-4)', 'var(--green-5)', 'var(--green-6)'];
            // --- GAME VARIABLES ---
            let paddle, ball, bricks, score, lives, gameState;
            let keys = {};
            
            const initGame = () => {
              gameState = 'running';
              score = 0; lives = 3;
              paddle = { x: (WIDTH - PADDLE_WIDTH) / 2 };
              resetBall(); createBricks();
              document.addEventListener('keydown', handleKeyDown);
              document.addEventListener('keyup', handleKeyUp);
              gameLoop();
            };
            
            const resetBall = () => { ball = { x: WIDTH / 2, y: HEIGHT - 3, dx: Math.random() > 0.5 ? 0.5 : -0.5, dy: -0.25 }; };
            const createBricks = () => {
              bricks = [];
              const brickRows = 4, brickCols = 10;
              const brickWidth = WIDTH / brickCols;
              for (let r = 0; r < brickRows; r++) { for (let c = 0; c < brickCols; c++) { bricks.push({ x: c * brickWidth, y: r + 2, width: brickWidth, alive: true, color: BRICK_COLORS[r % BRICK_COLORS.length] }); } }
            };
            
            const handleKeyDown = (e) => { keys[e.key] = true; };
            const handleKeyUp = (e) => { keys[e.key] = false; };
            
            const update = () => {
              if (gameState !== 'running') return;
              if (keys['ArrowLeft'] && paddle.x > 0) paddle.x -= 1;
              if (keys['ArrowRight'] && paddle.x < WIDTH - PADDLE_WIDTH) paddle.x += 1;
              ball.x += ball.dx; ball.y += ball.dy;
              if (ball.x <= 0 || ball.x >= WIDTH - 1) ball.dx *= -1;
              if (ball.y <= 0) ball.dy *= -1;
              if (ball.y >= HEIGHT - 1) { lives--; if (lives <= 0) { gameState = 'gameOver'; } else { resetBall(); } }
              const ballX = Math.floor(ball.x), paddleX = Math.floor(paddle.x);
              if (Math.floor(ball.y) === HEIGHT - 2 && ballX >= paddleX && ballX < paddleX + PADDLE_WIDTH) {
                ball.dy *= -1;
                let hitPos = (ball.x - (paddle.x + PADDLE_WIDTH / 2)) / (PADDLE_WIDTH / 2); // -1 to 1
                ball.dx = hitPos;
              }
              for (const brick of bricks) { if (brick.alive && Math.floor(ball.y) === Math.floor(brick.y) && Math.floor(ball.x) >= brick.x && Math.floor(ball.x) < brick.x + brick.width) { brick.alive = false; ball.dy *= -1; score += 10; } }
              if (bricks.every(b => !b.alive)) { gameState = 'win'; }
            };
            
            const draw = () => {
              term.clear();
              let grid = Array.from({ length: HEIGHT }, () => Array(WIDTH).fill(' '));
              for (const brick of bricks) { if (brick.alive) { for (let i = 0; i < Math.floor(brick.width); i++) { grid[Math.floor(brick.y)][Math.floor(brick.x) + i] = `<span style="color:${brick.color}">‚ñì</span>`; } } }
              for (let i = 0; i < PADDLE_WIDTH; i++) { grid[HEIGHT - 2][Math.floor(paddle.x) + i] = '‚ñÄ'; }
              grid[Math.floor(ball.y)][Math.floor(ball.x)] = 'O';
              let output = grid.map(row => row.join('')).join('\n');
              output += `\nScore: ${score} | Lives left: ${'‚ô•'.repeat(lives)}`;
              if (gameState === 'gameOver') { output += "\n\n  GAME OVER!"; } 
              else if (gameState === 'win') { output += "\n\n  YOU WON! CONGRATULATIONS!"; }
              term.print(output);
            };
            
            const gameLoop = () => {
              if (gameState === 'gameOver' || gameState === 'win') { draw(); exitGame(); return; }
              update();
              draw();
              requestAnimationFrame(gameLoop);
            };
            
            const exitGame = () => {
              document.removeEventListener('keydown', handleKeyDown);
              document.removeEventListener('keyup', handleKeyUp);
              term.print("\nTo play again, type 'breakout' and press Enter.");
              document.querySelector('.input-line').style.display = 'flex';
              resolve();
            };
            
            const masterInputHandler = (e) => { if (e.altKey && e.key.toLowerCase() === 'q') { e.preventDefault(); e.stopImmediatePropagation(); gameState = 'exit'; exitGame(); } };
            
            const showStartScreen = () => {
              term.clear();
              term.print("=== BREAKOUT ===");
              term.print("Smash all the bricks with the ball to win.\n");
              term.print("Controls:\n  Left/Right Arrow: Steer the paddle\n  Alt+Q: Quit game\n");
              term.print("Press any key to start...");
              document.addEventListener('keydown', function startHandler(e) {
                e.preventDefault(); e.stopImmediatePropagation();
                this.removeEventListener('keydown', startHandler);
                document.querySelector('.input-line').style.display = 'none';
                document.addEventListener('keydown', masterInputHandler, { capture: true });
                initGame();
              }, { once: true });
            };
            
            showStartScreen();
          });
        }
      }
    };
    SystemPrograms.push(breakoutProgram);
    // -------- END PROGRAM: BREAKOUT --------

    // -------- START PROGRAM: EDIT --------
    const editProgram = {
      name: 'edit',
      program: {
        description: 'A full-featured text and code editor with templates.',
        execute: async (term) => {
          return new Promise(resolve => {
            const CONTAINER_ID = 'editor-container-dynamic', STYLE_ID = 'editor-style-dynamic', EDITOR_ID = 'editor-textarea-dynamic', SEARCH_MODAL_ID = 'search-modal-dynamic';
            const shortcuts = [ { key: 'Ctrl + O', desc: 'Open file' }, { key: 'Ctrl + S', desc: 'Save file' }, { key: 'Alt + N', desc: 'New file (with WebDOS template)' }, { key: 'Alt + S', desc: 'Search & replace' }, { key: 'Alt + P', desc: 'Preview HTML' }, { key: 'Tab', desc: 'Indent' }, { key: 'Shift+Tab', desc: 'Outdent' }, { key: 'Alt + L', desc: 'Clean empty lines' }, { key: 'Alt + Q', desc: 'Quit editor' } ];
            term.print("--- Code Editor Shortcuts ---");
            shortcuts.forEach(s => term.print(`${s.key.padEnd(15, ' ')}: ${s.desc}`));
            term.print("\nPress any key to start the editor...");
            
            let hasUnsavedChanges = false;
            
            const exitEditor = () => {
              document.removeEventListener('keydown', masterKeyHandler, true);
              window.removeEventListener('beforeunload', beforeUnloadHandler);
              document.getElementById(CONTAINER_ID)?.remove();
              document.getElementById(STYLE_ID)?.remove();
              document.querySelector('.input-line').style.display = 'flex';
              resolve();
            };
            
            const beforeUnloadHandler = (e) => { if(hasUnsavedChanges) { e.preventDefault(); e.returnValue = ''; } };
            const masterKeyHandler = (e) => { document.dispatchEvent(new CustomEvent('editor-global-keydown', { detail: e })); };
            
            const setupAndRun = () => {
              document.querySelector('.input-line').style.display = 'none';
              const style = document.createElement('style'); style.id = STYLE_ID;
              style.textContent = `#${CONTAINER_ID}{position:fixed;top:0;left:0;width:100%;height:100%;z-index:100}#${EDITOR_ID}{width:100%;height:100%;box-sizing:border-box;border:none;outline:none;resize:none;white-space:pre;overflow-wrap:normal;overflow:auto;background-color:var(--black);color:var(--green-6);font-family:'Menlo','Monaco','Courier New',monospace;font-size:16px;padding:10px;caret-color:var(--green-7)}.${SEARCH_MODAL_ID}-class{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:400px;background-color:var(--black);border:2px solid var(--green-5);color:var(--green-6);z-index:110;padding:20px;box-shadow:0 0 20px rgba(88,222,17,.3)}.editor-modal-close-btn{position:absolute;top:10px;right:15px;font-size:24px;color:var(--green-6);cursor:pointer;background:0 0;border:none}#${SEARCH_MODAL_ID} h2{margin-top:0;text-align:left}#${SEARCH_MODAL_ID} .input-group{margin-bottom:15px}#${SEARCH_MODAL_ID} label{display:block;margin-bottom:5px}#${SEARCH_MODAL_ID} #match-count{float:right;font-size:.8em;color:var(--green-4)}#${SEARCH_MODAL_ID} input{width:100%;background-color:var(--green-0);border:1px solid var(--green-5);color:var(--green-6);padding:5px;box-sizing:border-box}#${SEARCH_MODAL_ID} .button-group{display:flex;justify-content:space-between;gap:10px}#${SEARCH_MODAL_ID} button{flex-grow:1;background:0 0;border:1px solid var(--green-5);color:var(--green-5);padding:8px;cursor:pointer}#${SEARCH_MODAL_ID} button:hover{background-color:var(--green-5);color:var(--black)}`;
              document.head.appendChild(style);
              const container = document.createElement('div'); container.id = CONTAINER_ID;
              container.innerHTML = `<textarea id="${EDITOR_ID}" spellcheck="false" autofocus></textarea><div id="${SEARCH_MODAL_ID}" class="${SEARCH_MODAL_ID}-class"><button id="search-close" class="editor-modal-close-btn">&times;</button><h2>Search & Replace</h2><div class="input-group"><label for="find-input">Find: <span id="match-count"></span></label><input type="text" id="find-input"></div><div class="input-group"><label for="replace-input">Replace with:</label><input type="text" id="replace-input"></div><div class="button-group"><button id="find-next-btn">Find Next</button><button id="replace-btn">Replace</button><button id="replace-all-btn">Replace All</button></div></div>`;
              document.body.appendChild(container);
              initEditorLogic();
              document.addEventListener('keydown', masterKeyHandler, true);
              window.addEventListener('beforeunload', beforeUnloadHandler);
            };
            
            const initEditorLogic = () => {
              const editor = document.getElementById(EDITOR_ID);
              const searchModal = document.getElementById(SEARCH_MODAL_ID);
              const findInput = document.getElementById('find-input');
              let currentFileHandle = null;
              
              const newFile = () => {
                if (hasUnsavedChanges && !confirm("Unsaved changes will be lost. Continue?")) return;
                const template = `
const myNewProgram = {
  name: 'myname',
  program: {
    description: 'A short description of the program.',
    execute: async (term) => {
      return new Promise(resolve => {
        term.print("My new program is running!");
        
        const exitProgram = () => {
          // Cleanup logic, if any, goes here.
          resolve();
        };
        
        exitProgram();
      });
    }
  }
};
SystemPrograms.push(myNewProgram);`;
                editor.value = template.trim(); currentFileHandle = null; hasUnsavedChanges = false; editor.focus();
                const cursorPos = template.indexOf('myname');
                editor.setSelectionRange(cursorPos, cursorPos + 'myname'.length);
              };
              
              const saveFile = async () => { if (!currentFileHandle) { try { currentFileHandle = await window.showSaveFilePicker({ suggestedName: 'program.js' }); } catch (err) { return; } } try { const writable = await currentFileHandle.createWritable(); await writable.write(editor.value); await writable.close(); hasUnsavedChanges = false; } catch(err) { console.error(err); } };
              const openFile = async () => { if (hasUnsavedChanges && !confirm("Unsaved changes will be lost. Continue?")) return; try { const [fileHandle] = await window.showOpenFilePicker(); const file = await fileHandle.getFile(); editor.value = await file.text(); currentFileHandle = fileHandle; hasUnsavedChanges = false; } catch (err) {} };
              const previewCode = () => { const win = window.open(); win.document.write(editor.value); win.document.close(); };
              const cleanEmptyLines = () => { editor.value = editor.value.split('\n').map(l => l.trimEnd()).filter(l => l !== '').join('\n'); };
              const toggleSearch = () => { searchModal.style.display = searchModal.style.display === 'block' ? 'none' : 'block'; if(searchModal.style.display === 'block') findInput.focus(); else editor.focus(); };
              
              editor.addEventListener('input', () => { hasUnsavedChanges = true; });
              editor.addEventListener('keydown', e => { if (e.key === 'Tab') { e.preventDefault(); document.execCommand('insertText', false, '  '); } });
              document.getElementById('search-close').addEventListener('click', toggleSearch);
              
              document.addEventListener('editor-global-keydown', e => {
                const originalEvent = e.detail;
                if (originalEvent.altKey && originalEvent.key.toLowerCase() === 'q') { originalEvent.preventDefault(); if (hasUnsavedChanges && !confirm("You have unsaved changes. Quit anyway?")) return; exitEditor(); }
                if(searchModal.style.display === 'block') { if(originalEvent.key === 'Escape') toggleSearch(); return; }
                const isCtrl = originalEvent.ctrlKey || originalEvent.metaKey;
                const key = originalEvent.key.toLowerCase();
                if(isCtrl && key === 's') { originalEvent.preventDefault(); saveFile(); }
                if(isCtrl && key === 'o') { originalEvent.preventDefault(); openFile(); }
                if(originalEvent.altKey && key === 'n') { originalEvent.preventDefault(); newFile(); }
                if(originalEvent.altKey && key === 'p') { originalEvent.preventDefault(); previewCode(); }
                if(originalEvent.altKey && key === 'l') { originalEvent.preventDefault(); cleanEmptyLines(); }
                if(originalEvent.altKey && key === 's') { originalEvent.preventDefault(); toggleSearch(); }
              });
              
              editor.focus();
            };
            
            document.addEventListener('keydown', function startHandler(e) { e.preventDefault(); e.stopImmediatePropagation(); setupAndRun(); }, { once: true });
          });
        }
      }
    };
    SystemPrograms.push(editProgram);
    // -------- END PROGRAM: EDIT --------

    document.addEventListener('DOMContentLoaded', () => {
      const terminalEl = document.getElementById('terminal');
      const inputLine = document.querySelector('.input-line');
      const inputBuffer = document.getElementById('input-buffer');
      const commandHistory = [];
      let historyIndex = -1;
      let commandBuffer = '';
      let isAppRunning = false;
      
      const programs = {};
      SystemPrograms.forEach(p => { if (p && p.name && p.program) { programs[p.name] = p.program; } });
      
      const terminal = {
        print: (message, options = {}) => {
          const newLine = document.createElement('div');
          if (options.commandText !== undefined) {
            newLine.classList.add('output-line', 'input-line');
            const promptSpan = document.createElement('span'); promptSpan.className = 'prompt'; promptSpan.textContent = message;
            const commandSpan = document.createElement('span'); commandSpan.className = 'input-text'; commandSpan.textContent = options.commandText;
            newLine.appendChild(promptSpan); newLine.appendChild(commandSpan);
          } else {
            newLine.classList.add('output-line');
            newLine.innerHTML = message;
            if (options.color && !message.includes('<span')) newLine.style.color = options.color;
            if (options.backgroundColor) { newLine.style.backgroundColor = options.backgroundColor; newLine.style.padding = '0 0.5ch'; }
          }
          terminalEl.insertBefore(newLine, inputLine);
          window.scrollTo(0, document.body.scrollHeight);
        },
        clear: () => {
          terminalEl.querySelectorAll('.output-line').forEach(line => line.remove());
        }
      };
      
      async function processCommand(command) {
        const [cmd, ...args] = command.trim().split(' ');
        const cmdLower = cmd.toLowerCase();
        if (!cmdLower) return;
        commandHistory.push(command);
        historyIndex = commandHistory.length;
        
        const aliases = { 'clear': 'clear', 'cls': 'clear', 'help': 'help', '?': 'help', 'echo': 'echo', 'dir': 'dir', 'ls': 'dir' };
        const resolvedCmd = aliases[cmdLower] || cmdLower;
        
        if (resolvedCmd in programs) {
          isAppRunning = true;
          try { await programs[resolvedCmd].execute(terminal, args); } 
          catch (error) { terminal.print(`Error in '${cmdLower}': ${error.message}`); } 
          finally { isAppRunning = false; }
          return;
        }
        
        switch (resolvedCmd) {
          case 'clear': terminal.clear(); break;
          case 'help':
            terminal.print('Core commands: clear, help, echo, dir');
            terminal.print('Aliases: cls, ?, ls\n');
            terminal.print('Type "dir" to see a list of available programs.');
            break;
          case 'echo': terminal.print(args.join(' ')); break;
          case 'dir':
            terminal.print('Contents of C:\\\n');
            const programNames = Object.keys(programs).sort();
            programNames.forEach(pName => {
              const description = programs[pName].description || '';
              terminal.print(`${pName.padEnd(15, ' ')}${description}`);
            });
            terminal.print(`\n\t${programNames.length} Program(s)`);
            break;
          default: terminal.print(`Invalid command or file name: '${cmd}'`);
        }
      }
      
      function updateInput() {
        inputBuffer.textContent = commandBuffer;
        window.scrollTo(0, document.body.scrollHeight);
      }
      
      document.addEventListener('keydown', async (e) => {
        if (isAppRunning) return;
        if (['Enter', 'Backspace', 'ArrowUp', 'ArrowDown'].includes(e.key)) e.preventDefault();
        if (e.key === 'Enter') {
          terminal.print(`C:\\>`, { commandText: commandBuffer });
          const commandToProcess = commandBuffer;
          commandBuffer = '';
          updateInput();
          await processCommand(commandToProcess);
        } else if (e.key === 'Backspace') {
          commandBuffer = commandBuffer.slice(0, -1);
        } else if (e.key === 'ArrowUp') {
          if (historyIndex > 0) { historyIndex--; commandBuffer = commandHistory[historyIndex]; }
        } else if (e.key === 'ArrowDown') {
          if (historyIndex < commandHistory.length - 1) { historyIndex++; commandBuffer = commandHistory[historyIndex]; } 
          else { historyIndex = commandHistory.length; commandBuffer = ''; }
        } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
          commandBuffer += e.key;
        }
        updateInput();
      });
      
      terminal.print('WebDOS [Version 1.0]');
      terminal.print("Type 'help' for a list of commands.");
    });
  </script>
</body>
</html>
