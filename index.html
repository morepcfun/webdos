<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WEB-DOS</title>
<style>
:root {
--black: #000000;
--green: var(--green-7);
--green-0: #051a00;
--green-1: #133b03;
--green-2: #215b06;
--green-3: #2e7c09;
--green-4: #3c9d0b;
--green-5: #4ab50e;
--green-6: #58de11;
--green-7: #65ff14;
}
html, body {
margin: 0;
padding: 0;
background-color: var(--black);
color: var(--green);
font-family: 'Courier New', Courier, monospace;
font-size: 20px;
}
#terminal {
padding: 10px;
}
.output-line {
white-space: pre-wrap;
}
.input-line {
display: flex;
align-items: center;
height: 1.2em;
}
.prompt {
flex-shrink: 0;
}
.input-text {
padding-right: 1ch;
white-space: pre;
}
#cursor {
display: inline-block;
background-color: var(--green);
width: 1ch;
height: 0.9em;
animation: blink 1s step-end infinite;
margin-left: -1ch;
margin-bottom: 0.2ch;
}
@keyframes blink {
from, to { background-color: transparent; }
50% { background-color: var(--green); }
}
</style>
</head>
<body>
<div id="terminal">
<div class="input-line">
<span class="prompt">C:\></span>
<span id="input-buffer" class="input-text"></span>
<span id="cursor"></span>
</div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
const terminalEl = document.getElementById('terminal');
const inputLine = document.querySelector('.input-line');
const inputBuffer = document.getElementById('input-buffer');
const commandHistory = [];
let historyIndex = -1;
let commandBuffer = '';
let isAppRunning = false;
const terminal = {
print: (message, options = {}) => {
const newLine = document.createElement('div');
if (options.commandText !== undefined) {
newLine.classList.add('output-line', 'input-line');
const promptSpan = document.createElement('span');
promptSpan.className = 'prompt';
promptSpan.textContent = message;
const commandSpan = document.createElement('span');
commandSpan.className = 'input-text';
commandSpan.textContent = options.commandText;
newLine.appendChild(promptSpan);
newLine.appendChild(commandSpan);
} else {
newLine.classList.add('output-line');
newLine.innerHTML = message;
if (options.color && !message.includes('<span')) {
newLine.style.color = options.color;
}
if (options.backgroundColor) {
newLine.style.backgroundColor = options.backgroundColor;
newLine.style.padding = '0 0.5ch';
}
}
terminalEl.insertBefore(newLine, inputLine);
},
clear: () => {
terminalEl.querySelectorAll('.output-line').forEach(line => line.remove());
}
};
const programs = {};
programs['about'] = {
description: 'Prints information about this system.',
execute: async (term) => {
term.print("WEB-DOS [Version 1.0]");
term.print("(c) 2025. A self-contained terminal environment.");
}
};
programs['colors'] = {
description: 'Displays all 8 colors in the system palette.',
execute: async (term) => {
term.print('--- System 8-Color Palette Test ---');
for (let i = 0; i <= 7; i++) {
const colorVar = `var(--green-${i})`;
term.print(`Sample text in --green-${i}`, { color: colorVar });
}
term.print('--- End of Palette ---', {
color: 'var(--black)',
backgroundColor: 'var(--green-7)'
});
}
};
programs['tetris'] = {
description: 'A classic block-stacking game.',
execute: async (term) => {
return new Promise(resolve => {
const BOARD_WIDTH = 10, BOARD_HEIGHT = 20, SCORES_KEY = 'webdos_tetris_highscores';
const COLORS = { BORDER: 'var(--green-4)', SCORE_TEXT: 'var(--green-6)', LOCKED_PIECE: 'var(--green-5)', GHOST_PIECE: 'var(--green-3)', ACTIVE_PIECE: 'var(--green-7)', GAME_OVER: 'var(--green-7)' };
const PIECES = { 'I': [[1,1,1,1]], 'O': [[1,1],[1,1]], 'T': [[0,1,0],[1,1,1]], 'L': [[0,0,1],[1,1,1]], 'J': [[1,0,0],[1,1,1]], 'S': [[0,1,1],[1,1,0]], 'Z': [[1,1,0],[0,1,1]] };
const PIECE_TYPES = 'IOTLJSZ';
let board, score, lines, gameOver, currentPiece, nextPiece, gameLoopId, gameState = 'start';
const inputLine = document.querySelector('.input-line');
const getHighScores = () => { try { const scores = localStorage.getItem(SCORES_KEY); return scores ? JSON.parse(scores) : []; } catch (e) { return []; } };
const saveHighScore = (newScore) => { if (newScore === 0) return; const scores = getHighScores(); scores.push({ score: newScore, date: new Date().toLocaleDateString() }); scores.sort((a, b) => b.score - a.score); localStorage.setItem(SCORES_KEY, JSON.stringify(scores.slice(0, 10))); };
const exitGame = (message) => {
if (gameLoopId) cancelAnimationFrame(gameLoopId);
document.removeEventListener('keydown', masterInputHandler, { capture: true });
terminal.clear();
if (message) {
terminal.print(message);
}
inputLine.style.display = 'flex';
resolve();
};
const createEmptyBoard = () => Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0));
const spawnPiece = () => { currentPiece = nextPiece; const type = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)]; nextPiece = { shape: PIECES[type], x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 }; if (checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y)) { gameOver = true; } };
const checkCollision = (shape, x, y) => { for (let row = 0; row < shape.length; row++) { for (let col = 0; col < shape[row].length; col++) { if (shape[row][col]) { let boardX = x + col; let boardY = y + row; if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT || (boardY >= 0 && board[boardY][boardX])) { return true; } } } } return false; };
const rotatePiece = () => { const shape = currentPiece.shape; const newShape = shape[0].map((_, colIndex) => shape.map(row => row[colIndex]).reverse()); if (!checkCollision(newShape, currentPiece.x, currentPiece.y)) { currentPiece.shape = newShape; } };
const lockPiece = () => { currentPiece.shape.forEach((row, y) => { row.forEach((value, x) => { if (value && (currentPiece.y + y) >= 0) { board[currentPiece.y + y][currentPiece.x + x] = 1; } }); }); };
const clearLines = () => { let linesCleared = 0; for (let y = BOARD_HEIGHT - 1; y >= 0; y--) { if (board[y].every(cell => cell !== 0)) { linesCleared++; board.splice(y, 1); board.unshift(Array(BOARD_WIDTH).fill(0)); y++; } } if (linesCleared > 0) { lines += linesCleared; score += (linesCleared * 100) * linesCleared; } };
const getGhostPosition = () => { let ghostY = currentPiece.y; while (!checkCollision(currentPiece.shape, currentPiece.x, ghostY + 1)) { ghostY++; } return ghostY; };
const draw = () => {
term.clear();
const ghostY = getGhostPosition();
const outputBuffer = [];
outputBuffer.push(`<span style="color:${COLORS.BORDER}">╔${'══'.repeat(BOARD_WIDTH)}╗</span>`);
for (let y = 0; y < BOARD_HEIGHT; y++) {
let line = `<span style="color:${COLORS.BORDER}">║</span>`;
for (let x = 0; x < BOARD_WIDTH; x++) {
const pieceX = x - currentPiece.x, pieceY = y - currentPiece.y, ghostPieceY = y - ghostY;
if (pieceY >= 0 && pieceY < currentPiece.shape.length && pieceX >= 0 && pieceX < currentPiece.shape[pieceY].length && currentPiece.shape[pieceY][pieceX]) {
line += `<span style="color:${COLORS.ACTIVE_PIECE}">██</span>`;
} else if (ghostPieceY >= 0 && ghostPieceY < currentPiece.shape.length && pieceX >= 0 && pieceX < currentPiece.shape[ghostPieceY].length && currentPiece.shape[ghostPieceY][pieceX]) {
line += `<span style="color:${COLORS.GHOST_PIECE}">░░</span>`;
} else if (board[y][x]) {
line += `<span style="color:${COLORS.LOCKED_PIECE}">▓▓</span>`;
} else {
line += '  ';
}
}
line += `<span style="color:${COLORS.BORDER}">║</span>`;
outputBuffer.push(line);
}
outputBuffer.push(`<span style="color:${COLORS.BORDER}">╚${'══'.repeat(BOARD_WIDTH)}╝</span>`);
outputBuffer.push(`<span style="color:${COLORS.SCORE_TEXT}">  Score: ${score}    Lines: ${lines}</span>`);
outputBuffer.push(`<span style="color:${COLORS.SCORE_TEXT}">  Next:</span>`);
if (nextPiece && nextPiece.shape) {
nextPiece.shape.forEach(row => {
const nextPieceLine = '  ' + row.map(cell => cell ? '██' : '  ').join('');
outputBuffer.push(`<span style="color:${COLORS.ACTIVE_PIECE}">${nextPieceLine}</span>`);
});
}
term.print(outputBuffer.join('\n'));
};
const masterInputHandler = (e) => {
if (e.altKey && e.key.toLowerCase() === 'q') {
e.preventDefault();
e.stopImmediatePropagation();
exitGame("Tetris quit by user.");
return;
}
e.stopImmediatePropagation();
switch (gameState) {
case 'start':
e.preventDefault(); gameState = 'playing'; runGame(); break;
case 'playing':
if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', ' '].includes(e.key)) e.preventDefault();
if (e.key === 'ArrowLeft') { if (!checkCollision(currentPiece.shape, currentPiece.x - 1, currentPiece.y)) currentPiece.x--;
} else if (e.key === 'ArrowRight') { if (!checkCollision(currentPiece.shape, currentPiece.x + 1, currentPiece.y)) currentPiece.x++;
} else if (e.key === 'ArrowDown') { if (!checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {currentPiece.y++; score +=1;} else { lockPiece(); clearLines(); spawnPiece(); }
} else if (e.key === 'ArrowUp') { rotatePiece();
} else if (e.key === ' ') { const ghostY = getGhostPosition(); score += (ghostY - currentPiece.y) * 2; currentPiece.y = ghostY; lockPiece(); clearLines(); spawnPiece(); }
draw(); break;
}
};
const showStartScreen = () => {
term.clear();
term.print("=== TETRIS ===", { color: COLORS.SCORE_TEXT });
term.print("Controls:\n  Left/Right: Move\n  Up: Rotate\n  Down: Soft drop\n  Space: Hard drop\n  Alt+Q: Force Quit\n");
term.print("Top 10 High Scores:");
const highScores = getHighScores();
if (highScores.length === 0) { term.print("  No scores yet. Be the first!"); }
else { highScores.forEach((s, i) => term.print(`${(i+1).toString().padStart(2)}. ${s.score.toString().padStart(6, ' ')} (${s.date})`)); }
term.print("\nPress any key to start...");
};
const runGame = () => {
board = createEmptyBoard(); score = 0; lines = 0; gameOver = false;
const firstType = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
nextPiece = { shape: PIECES[firstType], x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 };
spawnPiece();
let lastTime = 0;
let dropCounter = 0;
const gameLoop = (time = 0) => {
if (gameOver) {
saveHighScore(score);
terminal.print(`\n<span style='color: ${COLORS.GAME_OVER};'>Game Over!</span>`);
terminal.print("To play again, type 'tetris' and press Enter.");
cancelAnimationFrame(gameLoopId);
document.removeEventListener('keydown', masterInputHandler, {capture: true});
inputLine.style.display = 'flex';
resolve();
return;
}
const deltaTime = time - lastTime;
lastTime = time;
dropCounter += deltaTime;
if (dropCounter > 1000) {
if (checkCollision(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) { lockPiece(); clearLines(); spawnPiece(); } else { currentPiece.y++; }
dropCounter = 0;
}
draw();
gameLoopId = requestAnimationFrame(gameLoop);
};
gameLoop();
};
inputLine.style.display = 'none';
document.addEventListener('keydown', masterInputHandler, {capture: true});
showStartScreen();
});
}
};
async function processCommand(command) {
const [cmd, ...args] = command.trim().split(' ');
const cmdLower = cmd.toLowerCase();
if (!cmdLower) return;
commandHistory.push(command);
historyIndex = commandHistory.length;
if (cmdLower in programs) {
isAppRunning = true;
try {
await programs[cmdLower].execute(terminal, args);
} catch (error) {
terminal.print(`Error in '${cmdLower}': ${error.message}`);
} finally {
isAppRunning = false;
}
return;
}
switch (cmdLower) {
case 'cls':
terminal.clear();
break;
case 'help':
terminal.print('Core Commands: cls, help, echo, dir\n');
terminal.print('Type "dir" to see a list of available programs.');
break;
case 'echo':
terminal.print(args.join(' '));
break;
case 'dir':
terminal.print('Directory of C:\\\n');
const programNames = Object.keys(programs);
if (programNames.length > 0) {
programNames.forEach(pName => {
const description = programs[pName].description || '';
terminal.print(`${pName.padEnd(15, ' ')}${description}`);
});
}
terminal.print(`\n\t${programNames.length} Program(s)`);
break;
default:
terminal.print(`Bad command or file name: '${cmd}'`);
}
}
function updateInput() {
inputBuffer.textContent = commandBuffer;
window.scrollTo(0, document.body.scrollHeight);
}
document.addEventListener('keydown', async (e) => {
if (isAppRunning) return;
if (['Enter', 'Backspace', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
e.preventDefault();
}
if (e.key === 'Enter') {
terminal.print(`C:\\>`, { commandText: commandBuffer });
const commandToProcess = commandBuffer;
commandBuffer = '';
updateInput();
await processCommand(commandToProcess);
} else if (e.key === 'Backspace') {
commandBuffer = commandBuffer.slice(0, -1);
} else if (e.key === 'ArrowUp') {
if (historyIndex > 0) {
historyIndex--;
commandBuffer = commandHistory[historyIndex];
}
} else if (e.key === 'ArrowDown') {
if (historyIndex < commandHistory.length - 1) {
historyIndex++;
commandBuffer = commandHistory[historyIndex];
} else {
historyIndex = commandHistory.length;
commandBuffer = '';
}
} else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
commandBuffer += e.key;
}
updateInput();
});
terminal.print('WEB-DOS [Version 1.0]');
});
</script>
</body>
</html>